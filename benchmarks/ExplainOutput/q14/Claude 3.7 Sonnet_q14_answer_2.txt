# Tail Recursion in OCaml

A function is tail-recursive when the recursive call is the very last operation performed in the function - the final action before returning a value. This means the function doesn't need to keep track of any pending operations after the recursive call completes.

## Example of a tail-recursive function:

```ocaml
let sum_list_tail lst =
  let rec helper acc remaining =
    match remaining with
    | [] -> acc
    | hd::tl -> helper (acc + hd) tl
  in
  helper 0 lst
```

In this example, `helper` is tail-recursive because its recursive call is the final action in the function - there's nothing left to do after the recursive call returns.

## Non-tail-recursive example:

```ocaml
let rec sum_list lst =
  match lst with
  | [] -> 0
  | hd::tl -> hd + (sum_list tl)
```

This function is not tail-recursive because after the recursive call `sum_list tl` returns, we still need to add `hd` to the result.

Tail recursion matters because OCaml can optimize tail-recursive functions into loops, avoiding stack overflow for large inputs. The non-tail-recursive version needs to build up a stack frame for each recursive call to remember the pending addition operations.