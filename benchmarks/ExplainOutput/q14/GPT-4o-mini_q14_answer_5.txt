A function is tail-recursive when the recursive call is the last operation performed in that function. In other words, a tail-recursive function returns the result of the recursive call directly without performing any additional computation afterward. This allows the compiler or interpreter to optimize the function calls, reusing the current function's stack frame instead of creating a new one.

**Example:**

```ocaml
let rec factorial n acc =
  if n <= 1 then acc
  else factorial (n - 1) (n * acc)
```

In this `factorial` function, the recursive call `factorial (n - 1) (n * acc)` is the last operation in the function. When `n` reaches 1, the function returns `acc`, which holds the computed result.

Contrast this with a non-tail-recursive version:

```ocaml
let rec non_tail_factorial n =
  if n <= 1 then 1
  else n * non_tail_factorial (n - 1)
```

Here, the multiplication `n *` happens after the recursive call `non_tail_factorial (n - 1)`, making it non-tail-recursive. This means that every recursive call must wait for the result of `non_tail_factorial` before it can perform its multiplication, leading to higher stack usage.

In summary, a function is tail-recursive if the recursive call is the last operation, allowing for optimizations that can prevent stack overflow in cases of deep recursion.