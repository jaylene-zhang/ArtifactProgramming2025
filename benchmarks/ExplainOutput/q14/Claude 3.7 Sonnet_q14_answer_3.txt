# Tail Recursion Explanation

A function is tail-recursive when the recursive call is the very last operation performed in the function - there are no pending operations to complete after the recursive call returns.

## Example 1: Not Tail-Recursive
```ocaml
let rec factorial n =
  if n = 0 then 1
  else n * (factorial (n-1))
```
This is NOT tail-recursive because after `factorial (n-1)` returns, the function still needs to multiply that result by `n`. There's a pending operation after the recursive call.

## Example 2: Tail-Recursive
```ocaml
let factorial n =
  let rec aux n acc =
    if n = 0 then acc
    else aux (n-1) (n * acc)
  in
  aux n 1
```
This IS tail-recursive because in the recursive call `aux (n-1) (n * acc)`, all calculations are completed before making the recursive call. When the call happens, there's nothing left to do with the result except return it.

The key benefit is that the compiler can optimize tail-recursive functions to use constant stack space, regardless of input size, preventing stack overflows for large inputs.