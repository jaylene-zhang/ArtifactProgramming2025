**Solution:**

A function is tail-recursive if the recursive call is the very last operation performed in the function. In other words, after the recursive call returns, the function doesn't perform any further computations.

**Explanation:**

Tail recursion is important for optimization.  A tail-recursive function can be optimized by the compiler to reuse the current stack frame for the recursive call, preventing stack overflow errors when the recursion depth is large.

**Example (Tail-Recursive):**

```ocaml
let rec tail_recursive_sum n acc =
  if n = 0 then acc
  else tail_recursive_sum (n - 1) (acc + n)

(* Example usage: *)
let result = tail_recursive_sum 5 0
```

In this example, `tail_recursive_sum` is a tail-recursive function because the recursive call `tail_recursive_sum (n - 1) (acc + n)` is the last operation performed in the `else` branch.  When the recursive call returns, we simply return the value it computed; we don't perform any further operations on it. The accumulator `acc` is used to carry the intermediate results so no further computation is needed after the recursive call.

**Example (Not Tail-Recursive):**

```ocaml
let rec non_tail_recursive_sum n =
  if n = 0 then 0
  else n + non_tail_recursive_sum (n - 1)

(* Example usage: *)
let result = non_tail_recursive_sum 5
```

In this example, `non_tail_recursive_sum` is *not* tail-recursive.  After the recursive call `non_tail_recursive_sum (n - 1)` returns, we still need to add `n` to the result.  This means the recursive call isn't the very last thing that happens.  The function has to "unwind" and perform additional calculations on its way back up the call stack.
