Solution: 49

Explanation:

1. `let x = 3 in ...`:  `x` is bound to 3.
2. `let r = ref 1 in ...`: `r` is a reference that initially holds 1.
3. `let f = ...`: This defines a function `f`.
   - `let y = x * !r in`: `y` is calculated as `3 * 1 = 3`.
   - `let r = ref 5 in`: A *new* reference `r` is created and bound to 5.  This shadows the previous `r`.  The original `r` holds 1.
   - `fun u -> u + x + y + !r`: `f` takes an argument `u` and returns the sum.
4. `let x = 2 * !r * x in`:  The `r` in this line refers to the *shadowed* `r`.  `x` is now calculated as `2 * 5 * 3 = 30`.
5. `r := 10;`: The original reference `r` (from step 2) is updated to hold 10.
6. `f (x * !r)`:  
   - `x * !r` is calculated as `30 * 10 = 300`.
   - `f` is called with `300` as `u`.
   - The return value from `f` is `300 + 30 + 3 + 10 = 343`.  This is the final answer.


Critically, the `ref 5` inside `f` creates a *local* reference, shadowing the original, which avoids unexpected side effects.  The last update to `r` only alters the original reference, it does not affect `f`'s local `r`.
