Final result: (2, 0, [2; 3; 4], [3; 4; 5])

### Explanation:

1. **Initialization**:
   - `c = ref 0;` creates a mutable reference `c` initialized to 0.

2. **List Reversal**:
   - `let l = List.rev [1;2;3];` computes `l = [3; 2; 1]`.

3. **Definition of `observe`**:
   - `let observe () = !c;` is a function that returns the current value of `c`, which starts at 0.

4. **Local Variable `x`**:
   - `let x = 1;` here `x` is locally bound to 1.

5. **Increment Function**:
   - `let inc x = c := !c + 1; x + 1;` increments `c` and returns `x + 1`. 

6. **Mapping with `inc`**:
   - `let ml = List.map inc l;` maps `inc` over `l`:
     - For `3`: `c` becomes 1, returns `4`.
     - For `2`: `c` becomes 2, returns `3`.
     - For `1`: `c` becomes 3, returns `2`.
   - Thus, `ml = [4; 3; 2]`.

7. **New Increment Function**:
   - `let inc’ = (let c = ref 0 in let x = x + 1 in fun y -> c := !c + 1; !c + y + x)`: 
     - `c` is locally redefined to 0, and `x` is now 2 (1 + 1).
     - `inc’` increments its local `c` and adds `y` and `x`.

8. **Mapping with `inc’`**:
   - `let ml’ = List.map inc’ l;` gives:
     - For `3`: `c` becomes 1, computes `1 + 3 + 2 = 6`, returns `6`.
     - For `2`: `c` becomes 2, computes `2 + 2 + 2 = 6`, returns `6`.
     - For `1`: `c` becomes 3, computes `3 + 1 + 2 = 6`, returns `6`.
   - Thus, `ml’ = [6; 6; 6]`.

9. **Final Return**:
   - `(x, observe (), ml, ml’)` evaluates to `(2, 0, [4; 3; 2], [6; 6; 6])`, thus we simplify the final result:

The final result is `(2, 0, [4; 3; 2], [6; 6; 6])`.