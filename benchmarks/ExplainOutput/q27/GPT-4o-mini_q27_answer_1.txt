Functional languages avoid state variables and imperative-style programming to promote immutability, which leads to easier reasoning about code, higher modularity, and better support for concurrency. This approach minimizes side effects, making functions predictable and enabling safe composition. 

By avoiding mutable state, programs can be more straightforward to understand and debug since the behavior of functions doesn't change based on external state or previous invocations, allowing for easier reasoning about code correctness and behavior.