**Solution**
```ocaml
let x = 3 in
let r = ref (2 + x) in
let f = (let y = x *!r in
let r = ref 4 in fun u -> u + x + y +!r ) in
let x = 5 in
let y = 10 in
r := 2 ; f (!r * y)
```
**Binding Stack**

* `x = 3` (initial binding)
* `r ----> ref (2 + x)` (new binding)
* `(let y = x *!r in...)` (new scope)
	+ `y = x *!r` (new binding)
	+ `r = ref 4` (new binding)
	+ `f u -> u + x + y +!r` (new function binding)
* `x = 5` (new binding)
* `y = 10` (new binding)
* `r := 2` (assignment)
* `f (!r * y)` (function call)
	+ `(!r * y) = 2 * 10 = 20`
	+ `f 20 = 20 + 5 + y + 2 = 29` (function evaluation)

**Result**: `29`

Note that `x` is rebound to `5` before the function `f` is evaluated, but the original binding of `x` to `3` is not overwritten until after the function `f` is evaluated.