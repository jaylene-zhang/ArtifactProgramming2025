**No**

The given program does not correctly compute the antiderivative of `f`. The `anti_d` function should calculate the integral of `f(x)` from `0` to `x`, where `x` is a variable, but the given code fixes the upper bound to `0` instead of a variable. 

A correct implementation would be:
```ocaml
let anti_d f x = (curry integral) f (0, x)
``` 
or using curry on integral first and then on anti_d:
```ocaml
let integral_curry = curry integral
let anti_d f = fun x -> integral_curry f (0, x)
```