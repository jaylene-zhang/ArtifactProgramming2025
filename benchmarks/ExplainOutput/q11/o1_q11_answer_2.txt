Solution:
1) zip has the type:  
   let rec zip (l1: 'a list) (l2: 'b list) : ('a * 'b) list = …
2) zipper has the type:  
   let rec zipper (comb: 'a -> 'b -> 'c) (add: 'c -> 'c list -> 'c list)  
                  (l1: 'a list) (l2: 'b list) : 'c list = …  
3) Inside zipper's pattern match:  
   | x::xs, y::ys -> add (comb x y) (zipper comb add xs ys)

Explanation:
• For zip, each element of type 'a in l1 is paired with an element of type 'b in l2, so its return type is ('a * 'b) list.  
• In zipper, comb combines elements from the two lists ('a -> 'b -> 'c), and add inserts the new element of type 'c into the result of type 'c list. The recursive call continues with the tails of both lists.