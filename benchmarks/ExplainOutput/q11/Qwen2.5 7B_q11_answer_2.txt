```ocaml
let rec zipper (comb: 'a -> 'b -> 'res) (add: 'res list -> 'res -> 'res list)
  (l1: 'a list) (l2: 'b list) : 'res list =
  match l1, l2 with
  | [] , [] -> []
  | x::xs, y::ys -> comb x y :: add (zipper comb add xs ys) (comb x y)

let zip = zipper (fun x y -> (x, y)) (fun h t -> h :: t)
let zip_rev= zipper (fun x y -> (string_of_int x) ^ y)
  (fun s t -> t @ [ (s, List.length t) ])
```

### Explanation:

1. **General Types for `zipper`:**
   - `comb`: This is a function that will combine elements from `l1` and `l2`, thus it needs a type `'a -> 'b -> 'res` where `'a` and `'b` are the types of elements in `l1` and `l2` respectively, and `'res` is the type of the result of combining these elements.
   - `add`: This is a function that adds the result of `comb x y` to the list, so its type should be `'res list -> 'res -> 'res list`. It represents how results are accumulated in the list to be returned.
   - `l1` and `l2`: Both are lists of some type, so they are `'a list` and `'b list` respectively.
   - The return type `res list` is a list of results generated by combining elements from `l1` and `l2` using `comb`.

2. **Implementation of `zip` and `zip_rev`:**
   - `zip` uses a simple tuple `(x, y)` for combining the elements.
   - `add` for `zip` uses the `::` operator to prepend the combined result to the rest of the accumulated list.
   - `zip_rev` uses string concatenation for combining elements.
   - `add` for `zip_rev` uses `@` and `::` to append a tuple to the list, and also encodes the length of the concatenated string in the tuple.