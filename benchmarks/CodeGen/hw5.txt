Let’s assume a binary tree is represented using the following definition.
type ’a tree = Empty | Tree of ’a tree * ’a * ’a tree;;
Each node is in itself a tree and carries an item of type 'a. Additionally, each node has a left and right subtree. Leaf nodes are marked with an Empty left and right subtree. This definition is very similar to that of list, with the difference being that each Node (item) has two sub-Nodes in a tree, compared to one in case of a list.

Question 1 : Finding Depth of a Tree
Our first goal is to find the depth of such trees. A recursive tree_depth implementation has been provided. Our job is to write a Continuation Passing Style (CPS) implementation of the same function.
To maintain compatibility with the predefined signature, you should define an internal helper function with success/failure continuations. For this question, since the property "depth" exists for all trees, you should be able to write an implementation just by using success continuations. Such an helper would have the following signature:
depth_helper: 'a tree -> (int -> int) -> int

(* Question 1: Tree Depth *)


let rec tree_depth t = match t with
  | Empty -> 0
  | Tree (l, _, r) -> 1 + max (tree_depth l) (tree_depth r)

(* TODO: Implement a CPS style tree_depth_cps function.*)
let tree_depth_cps t = 
  raise NotImplemented


Question 2 : Finding Subtrees

t2 is a subtree of t1. Nodes c, d and e are also subtrees of t1, containing a single node each, but the node b is not a subtree on its own. t1 is also considered a subtree of itself. Additionally, an empty tree is a subtree of everything.
A prefix of a subtree is the path from the root node of the tree (node a in our example) to the parent node of the subtree. This path is defined for the purpose of this question in terms of elements, not in terms of left/right traversal. For instance, the prefix of t2 is [a], the prefix of subtree c (or d) is [a;b], and the prefix of t1 is [].
Given a prefix p and a binary tree t, your task is to find a subtree t’ with prefix p in t. When there are multiple subtrees with the same given prefix, you should find the leftmost subtree. Please initialize the success and failure continuations properly so that the return type is ’a tree option . The type option is defined as follows.
type ’a option = None | Some of ’a
Note that your implementation should be as general as possible. If later on we would like to return a bool value instead, we only need to adjust the initial success and failure continuations (i.e. no changes should be made to helper).

(* Question 2: Finding Subtrees *)


(* TODO: Implement a CPS style find_subtree_cont function.*)
let find_subtree_cps ls tree =
  let rec helper ls tree sc fc =
    raise NotImplemented
  in
  helper ls tree (fun() -> ()) (fun() -> ())




Question 3 : Parser


(* Question 3: Arithmetic Experssion Parser *)

Our last question involves writing a CPS parser that implements the grammar we discussed in our last section (with order of operations). Your parser needs to use the continuation style with success and failure functions. The parser_cps function returns an optional expression i.e. Some(expr) in case of successful parsing and None if the parsing failed.

You will need separate helpers for each of the four rules in our grammar. To make things easier, start with a recursive implementation of each of the rules and then subsequently convert them to a continuation passing style. The type signature of these helpers is provided for your ease.

Finally, since Plus(Const(4), Const(3)) and Plus(Const(3), Const4) are mathematically equivalent, we will be evaluating the success of your parser using the check_parser function. check_parser evaluates the expression generated by your parser to gauge its correctness (Don't change its implementation).

Warning: You will get zero points if you do not implement the functions using continuation passing style with success/failure functions as instructed, even if the autograder says you have passed the tests!



(* TODO: Implement a CPS style parser function.*)
type ('r, 'a) parser_LN = token list -> (unit -> 'r) -> (token list -> 'a -> 'r) -> 'r

let parser_cps t =
  raise NotImplemented

let check_parser t v = match parser_cps t with
  | None -> None
  | Some(e) -> Some(eval e v)
