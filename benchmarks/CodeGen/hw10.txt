A DIY programming language: MiniCAML
This homework we explore how to implement evaluation, type checking, and type inference for MiniCAML.

The grammar of MiniCAML is the following.

Type $\tau$	$"::="$	$ \text{int}\ |\ \text{bool}\ |\ tau_1\ \ldots\ tau_n \to tau $
Expression $e$	$"::="$	$ \ldots\ |\ \text{rec}\ (f: tau) \Rightarrow e\ |\ \text{fun}\ (x_1: tau_1, \ldots, x_n: tau_n) \Rightarrow e\ |\ e\ e_1\ \ldots\ e_n $
If you are not sure how to read this, please refer to the course notes: chapter 10, section 10.1.

Question 1: eval
In this question, we implement an interpreter based on big-step evaluation, meaning that the interpreter takes as input an expression and outputs a value, an expression in which no more computation is possible. Below are the inference rules for big-step evaluation of the new constructs in MiniCAML. These can be translated almost directly into OCaml code if you read them bottom-up. For an in-depth refresher on evaluation and inference rules, see section 10.2. of the course notes.

$ (["rec"\ (f: \tau) rArr e // f] e ⇓ v) / ("rec"\ (f: \tau) rArr e ⇓ v) "b-rec" $
$ () / ("fun"\ (x_1: tau_1, \ldots, x_n: tau_n) rArr e ⇓ "fun"\ (x_1: tau_1, \ldots, x_n: tau_n) rArr e) "b-fn" $
$ ((e ⇓ "fun"\ (x_1: tau_1, \ldots, x_n: tau_n) rArr e^{'}) \quad\quad ("for all"\ i.\ \quad e_i ⇓ v_i) \quad\quad [v_1//x_1, \ldots, v_n//x_n]e^{'} ⇓ v) / (e\ e_1\ \ldots\ e_n ⇓ v) "b-app" $

Implement, the missing cases of the function eval: exp -> exp. The functions subst : exp * name -> exp -> exp and subst_list : (exp * name) list -> exp -> exp from HW9 are in scope (but hidden), and you should use them to implement eval. You may also find the library function List.combine helpful.

If your evaluator encounters a situation not represented by these rules, you should raise the exception Stuck with the appropriate value of type runtime_error as defined in the prelude. For the missing cases of eval, you will need to raise the following runtime errors:

If a function is called with the incorrect number of arguments, you should raise Stuck Arity_mismatch.

If the function expression of Apply does not evaluate to a function value, you should raise Stuck Apply_non_fn.

Note that for this question you only need to implement the cases for Rec and Apply (since functions are already values, they do not need to be evaluated any more!).

(* TODO: Implement the missing cases of eval. *)
let rec eval exp =
  match exp with
  (* Values evaluate to themselves *)
  | I _ -> exp
  | B _ -> exp
  | Fn _ -> exp

  (* This evaluator is _not_ environment-based. Variables should never
     appear during evaluation since they should be substituted away when
     eliminating binding constructs, e.g. function applications and lets.
     Therefore, if we encounter a variable, we raise an error.
  *)
  | Var x -> raise (Stuck (Free_variable x))

  (* Primitive operations: +, -, *, <, = *)
  | Primop (po, args) ->
      let args = List.map eval args in
      begin
        match eval_op po args with
        | None -> raise (Stuck Bad_primop_args)
        | Some v -> v
      end

  | If (e, e1, e2) ->
      begin
        match eval e with
        | B true -> eval e1
        | B false -> eval e2
        | _ -> raise (Stuck If_non_true_false)
      end

  | Let (x, e1, e2) ->
      let e1 = eval e1 in
      eval (subst (e1, x) e2)

  | Rec (f, _, e) -> raise NotImplemented

  | Apply (e, es) -> raise NotImplemented




Question 2: infer
In this question, the goal is to infer the type of an expression. Since functions and recursion include type annotations, every expression is guaranteed to have a unique type. (This is something you would prove in COMP 527, but for now simply accept it as fact.)

To describe the type inference algorithm you must implement, we will use typing rules. The main judgement of the rule is

$\Gamma \vdash e:\ tau$
meaning "in context $\Gamma$, infer type $tau$ for expression $e$." See chapter 10 of the course notes for a review on typing, and particularly section 11.3 for a review on contexts.
The inference rules for the new categories of expressions are the following.

$ (\Gamma, x_1: tau_1,\ \ldots,\ x_n: tau_n \vdash e:\ \tau) / (\Gamma \vdash ("fun"\ (x_1: tau_1, \ldots, x_n: tau_n) rArr e):\ tau_1\ \ldots\ tau_n \to tau) "t-fn" $
$ ((\Gamma \vdash e:\ tau_1\ \ldots\ tau_n \to tau) \quad\quad ("for all"\ i \quad\quad \Gamma \vdash e_i:\ \tau_i)) / (\Gamma \vdash e\ e_1\ \ldots\ e_n:\ tau) "t-app" $
$ (\Gamma, f: tau \vdash e:\ tau^{'} \quad\quad tau = tau^{'}) / (\Gamma \vdash ("rec"\ (f: tau) rArr e):\ tau) "t-rec" $
Using these inference rules, fill in the missing cases of infer: context -> exp -> tp. The type of a context is defined for you in the prelude; we also provide the functions extend: context -> (name * tp) -> context and extend_list: context -> (name * tp) list -> context for extending a given context with one or several type ascriptions. If you encounter a type error during type inference, you should raise the exception TypeError with the appropriate value of type type_error as defined in the prelude. For the missing cases of infer, you will need to raise the following type errors:

If the function expression of Apply has type t', where t' is not of an Arrow type, you should raise the exception TypeError (Apply_non_arrow t').

If you encounter a type mismatch (expected something of type t, but instead found something of type t'), you should raise the exception TypeError (Type_mismatch t t'). We have defined a helper function type_mismatch in the prelude for this. Note: be mindful of the order of arguments to type_mismatch! The first argument should be the expected type, and the second should be the actual type encountered.

(* TODO: Implement the missing cases of infer. *)
let rec infer ctx e =
  match e with
  | Var x ->
      begin
        try lookup x ctx
        with Not_found -> raise (TypeError (Free_variable x))
      end
  | I _ -> Int
  | B _ -> Bool

  | Primop (po, exps) ->
      let (domain, range) = primopType po in
      check ctx exps domain range

  | If (e, e1, e2) ->
      begin
        match infer ctx e with
        | Bool ->
            let t1 = infer ctx e1 in
            let t2 = infer ctx e2 in
            if t1 = t2 then t1
            else type_mismatch t1 t2
        | t -> type_mismatch Bool t
      end

  | Let (x, e1, e2) ->
      let t1 = infer ctx e1 in
      infer (extend ctx (x, t1)) e2

  | Rec (f, t, e) -> raise NotImplemented

  | Fn (xs, e) -> raise NotImplemented

  | Apply (e, es) -> raise NotImplemented

and check ctx exps tps result =
  match exps, tps with
  | [], [] -> result
  | e :: es, t :: ts ->
      let t' = infer ctx e in
      if t = t' then check ctx es ts result
      else type_mismatch t t'
  | _ -> raise (TypeError Arity_mismatch)



Question 3: Unification
We take the first steps towards extending MiniCAML to support full type inference, like in OCaml. Remember that in OCaml, it isn't necessary to write type annotations anywhere: the compiler can figure out the types of all variables for you based on how you define and use them. The upshot of adding full type inference to MiniCAML is that we can remove the type annotations on the Fn and Rec constructors for exp.

The key algorithm we need to implement type inference is unification, which checks if two types can be made syntactically equal by simultaneously substituting types for type variables. For example, if asked to unify $\alpha$ with $"Int" -> "Int"$, then the solution is simply $[ ("Int" -> "Int") // \alpha ]$; if asked to unify $\alpha -> \beta$ with $"Int" -> "Bool"$, then the solution is $[ "Int" // \alpha,\ "Bool" // \beta ]$. These solutions are called unifiers, and are representated in the template as an immutable mapping from variable names to types as utp UTVarMap.t, with module UTVarMap = Map.Make (String) defined in the prelude.

To support variables such as $\alpha$ and $\beta$ in types, we extend the datatype tp (the new extended type is called utp, and we have prefixed all old constructors with U, so that Int is now UInt, etc.) with the constructor UTVar of string: we model type variables using variable names as strings.

Unification fails in two situations.

We are trying to unify two different (mismatched) concrete types, e.g. unifying UInt with UBool fails.
We are trying to unify a variable UTVar "a" with a different type containing that variable, e.g. UArrow (UInt, UTVar "a"). This error is subtler, and requires a more explicit check.
For example, suppose we try to unify UTVar "a" and UArrow (UInt, UTVar "a"). Then, every occurrence of UTVar "a" should be replaced with UArrow (UInt, UTVar "a"). However, the substitution could be repeatedly applied without ever eliminating the type variable UTVar "a". That is, successively applying the invalid unifier $[ ("Int" -> \alpha) // \alpha ]$ to $\alpha$ yields:
$\alpha$
$"Int" -> \alpha$
$"Int" -> ("Int" -> \alpha)$
$"Int" -> ("Int" -> \("Int" -> \alpha))$
$\cdots$
Theoretically, what has happened is that the type has become infinite.
So we forbid these circular references. Instead, when unifying a variable against a type, you must check that the variable does not occur in that type. To do so, the function occurs : utp -> bool is provided to you as a local helper for unifyVar.
In sum, the unification algorithm for variable a with the type t is the following.

If a occurs in t, then raise an appropriate exception.
Otherwise, check whether a substitution is already defined for a.
If there is already a type t' to substitute in for a, then unify t with t'.
If not, then set t as the type to substitute in for a.
Note that the substitution of a type for a type variable is not propagated throughout the data structure for the unifier. This has the consequence that programs using one such unifier have to be context-dependent, as is the case with the string_of_utp : utp UTVarMap.t -> utp and string_of_type_substitution : utp UTVarMap.t -> string functions defined in the prelude.

Your task is to complete the implementation of the function unify : utp -> utp -> utp UTVarMap.t which takes two types t1 and t2 and constructs a unifier such that applying it to t1 and t2 produces structurally equal types. If the two types are not unifiable, you should raise the exception UnifError as defined for you in the prelude.
In the template, the cases for the local unify function are given, with a missing implementation for the arrow type case (for functions) and the cross type case (for tuples). It is your task to fill in the missing case, and to complete the implementation of unifyVar following the algorithm description above.


(* TODO: Implement type unification. *)
let unify : utp -> utp -> utp UTVarMap.t =
  let rec unify (type_substitution : utp UTVarMap.t) (t1 : utp) (t2 : utp) : utp UTVarMap.t =
    match t1, t2 with
    (* Unifying identical concrete types does nothing *)
    | UInt, UInt
    | UBool, UBool -> type_substitution
    | UTVar a, UTVar a' when a = a' -> type_substitution

    (* For type constructors, recursively unify the parts *)
    | UArrow (t1, t1'), UArrow (t2, t2') ->
        raise NotImplemented

    | UCross ts1, UCross ts2 ->
        raise NotImplemented

    | UTVar a, _ -> unifyVar type_substitution a t2
    | _, UTVar b -> unifyVar type_substitution b t1
    (* All other cases are mismatched types. *)
    | _, _ -> unif_error @@ UnifMismatch (t1, t2)

  (* Unify a variable with a type *)
  and unifyVar (type_substitution : utp UTVarMap.t) (a : string) (t : utp) : utp UTVarMap.t =
    let rec occurs : utp -> bool = function
      | UInt | UBool -> false
      | UArrow (t1, t2) -> occurs t1 || occurs t2
      | UCross ts -> List.exists occurs ts
      | UTVar b ->
          if a = b
          then true
          else
            match UTVarMap.find_opt b type_substitution with
            | None -> false
            | Some t' -> occurs t'
    in
    raise NotImplemented

  in
  fun t1 t2 -> unify UTVarMap.empty t1 t2
