SAT

In this assignment, you will use exception-based backtracking to solve a well-known problem called SAT. SAT is short for "boolean satisfiability." Simply put, if you have a boolean formula with variables, SAT asks if there is any way to assign true and false to each variable so that the value of the formula is true. In this assignment, we write & for boolean AND, | for boolean OR, and ~ for boolean NOT.

For example, the formula x & ~y is satisfiable, by assigning x to true and y to false. The formula x & ~x is not satisfiable, because no matter what value we give to x, x & ~x will be false.

Boolean Formulae

In HW2, you worked with expression trees of floats. In this assignment, you will work with a different type, formula, of boolean expressions. The biggest difference is that in HW2, the tree had one unnamed variable. In this HW, the trees can have many named variables.

The Conjunction and Disjunction constructors represent boolean AND and boolean OR, respectively.

When evaluating expressions in HW2, you had to pass in a value to use for that variable. In this HW, the trees have many named variables. When evaluating expressions, you will have to use a dictionary from variable names to boolean values. These dictionaries are called truth assignments. You will also want to know all of the variables which appear in an expression, which is a set of names.

In the Prelude for this assignment, we've given you a function parse_formula : string -> formula. It parses expressions like those shown above, including "(a | ~b) & c", "~~a" and "a1 | a2 | a3".

You are not required to understand how the parser works, but feel free to look around the implementation if you are interested.

Variable_set and Variable_map

In order to make sets of variables and dictionaries of variables, we have defined the Variable_set and Variable_map modules for you. The interface is very similar to simplified one you saw in class. These modules are defined using OCaml's standard Set.Make and Map.Make functors. The links in the previous sentence will take you to their documentation.

(* Given:*)
module Variable_set = Set.Make (String)
module Variable_map = Map.Make (String)

For example, we could define the set of variables {x,y,z} as

let xyz : Variable_set.t
    =  Variable_set.singleton "x"
    |> Variable_set.add "y"
    |> Variable_set.add "z";;
We could also define the truth assignment that maps x to true, and y and z to false:

let xyz_truth_asgn : truth_assignment
    =  Variable_map.singleton "x" true
    |> Variable_map.add       "y" false
    |> Variable_map.add       "y" false


Implement the function collect_variables : formula -> Variable_set.t.

(* Given: *)
type formula =
  | Variable of string
  | Conjunction of formula * formula
  | Disjunction of formula * formula
  | Negation of formula

This function takes a formula and returns the set of variable names which appear anywhere in the formula. You may use any functions you want and whichever recursive style you prefer.

(* TODO: Implement the function. *)
let collect_variables (formula : formula) : Variable_set.t =
  raise Not_implemented


 Question 2 (15 points)
Implement the function eval : truth_assignment -> formula -> bool.
This function is very similar to the eval function from HW2. However, now you are evaluating boolean formulae instead of float arithmetic. You also need to use the correct boolean value for each variable. We recommend using Variable_map.find_opt to perform lookups in the truth assignment. If a variable is needed but does not appear in the truth assignment, you must raise an Unassigned_variable x exception, where x is the unassigned variable.
Once again, you may use any functions you want and whichever recursive style you prefer.

module Variable_set = Set.Make (String)
module Variable_map = Map.Make (String)

let variable_set_to_list = Variable_set.elements
let variable_map_to_list = Variable_map.bindings

(* TODO: Implement the function. *)
let eval (state : truth_assignment) (formula : formula) : bool =
  raise Not_implemented



Implement the function find_satisfying_assignment : formula -> truth_assignment.
This function takes a formula and produces a truth_assignment which makes the formula evaluate to true.
If no such assignment exists, you must raise an Unsatisfiable_formula exception.
The truth assignment you return must be sharp, which means it must have an assignment for every variable in the expression and no others.
You can (and should) use the functions from both previous problems.
You must use exception-based backtracking search to implement this function. The autograder will not check this.
The test cases you must implement for this problem use truth_assignment option as output type. A None output corresponds to find_satisfying_assignment raising an exception on an unsatisfiable formula given as input. A Some t output corresponds to find_satisfying_assignment succeeding with t as satisfying truth assignment.

type truth_assignment = bool Variable_map.t

exception Unassigned_variable of string

exception Unsatisfiable_formula

(* TODO: Implement the function. *)
let find_satisfying_assignment (formula : formula) : truth_assignment =
  raise Not_implemented