Here's how you can implement the functions according to the spec:

### free_variables

```ocaml
let rec free_variables : exp -> name list =
  (* Taking unions of lists.
     If the lists are in fact sets (all elements are unique),
     then the result will also be a set.
  *)
  let union l1 l2 = delete l2 l1 @ l2 in
  let union_fvs es =
    List.fold_left (fun acc exp -> union acc (free_variables exp)) [] es
  in
  function
  | Var y -> [y]
  | I _ | B _ -> []
  | If(e, e1, e2) -> union_fvs [e; e1; e2]
  | Primop (_, args) -> union_fvs args
  | Fn (xs, e) ->
      let bound_vars = List.map fst xs in
      delete bound_vars (free_variables e)
  | Rec (x, _, e) ->
      delete [x] (free_variables e)
  | Let (x, e1, e2) ->
      union (free_variables e1) (delete [x] (free_variables e2))
  | Apply (e, es) -> union_fvs (e :: es)
```

### unused_vars

```ocaml
let rec unused_vars =
  function
  | Var _ | I _ | B _ -> []
  | If (e, e1, e2) -> unused_vars e @ unused_vars e1 @ unused_vars e2
  | Primop (_, args) ->
      List.fold_left (fun acc exp -> acc @ unused_vars exp) [] args
  | Let (x, e1, e2) ->
      let unused = unused_vars e1 @ unused_vars e2 in
      if List.mem x (free_variables e2) then
        unused
      else
        x :: unused

  | Rec (x, _, e) ->
      if List.mem x (free_variables e) then
        unused_vars e
      else
        x :: unused_vars e

  | Fn (xs, e) ->
      let bvars = List.map fst xs in
      let unused = unused_vars e in
      let unused =
        List.fold_left
          (fun acc x ->
             if List.mem x (free_variables e) then acc else x :: acc)
          unused bvars
      in
      unused

  | Apply (e, es) ->
      List.fold_left (fun acc exp -> acc @ unused_vars exp) (unused_vars e) es
```

### subst

```ocaml
let rec subst ((e', x) as s) exp =
  match exp with
  | Var y ->
      if x = y then e'
      else Var y
  | I n -> I n
  | B b -> B b
  | Primop (po, args) -> Primop (po, List.map (subst s) args)
  | If (e, e1, e2) ->
      If (subst s e, subst s e1, subst s e2)
  | Let (y, e1, e2) ->
      let e1' = subst s e1 in
      if y = x then
        Let (y, e1', e2)
      else
        let (y, e2) =
          if List.mem y (free_variables e') then
            rename y e2
          else
            (y, e2)
        in
        Let (y, e1', subst s e2)

  | Rec (y, t, e) ->
      if y = x then Rec (y, t, e) else
      let (y, e) =
        if List.mem y (free_variables e') then
          rename y e
        else
          (y, e)
      in
      Rec (y, t, subst s e)

  | Fn (xs, e) ->
      let bvars = List.map fst xs in
      if List.mem x bvars then Fn (xs, e) else
      let xs, e =
        List.fold_right
          (fun (y, _) (xs, e) ->
             if List.mem y (free_variables e') then
               let (y', e') = rename y e in
               ((y', List.assoc y' (List.map (fun (v, tp) -> (v, tp)) xs)) :: xs, e')
             else
               ((y, List.assoc y (List.map (fun (v, tp) -> (v, tp)) xs)) :: xs, e))
          xs
          ([], e)
      in
      Fn (xs, subst s e)

  | Apply (e, es) -> Apply (subst s e, List.map (subst s) es)
```