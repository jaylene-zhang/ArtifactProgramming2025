exception NotImplemented

(* Types in MiniCAML *)
type tp =
  | Arrow of tp list * tp   (* function type: S1 S2 ... Sn -> T *)
  | Int
  | Bool

(* Used for variables, aka "identifiers" *)
type name = string

(* The primitive operations available in MiniCAML *)
type primop = Equals | LessThan | Plus | Minus | Times | Negate

(* Expressions in MiniCAML *)
type exp =
  | I of int                          (* 0 | 1 | 2 | ... *)
  | B of bool                         (* true | false *)
  | If of exp * exp * exp             (* if e then e1 else e2 *)
  | Primop of primop * exp list       (* e1 <op> e2  or <op> e *)
  | Fn of (name * tp) list * exp      (* fn (x_1: t_1, ..., x_n: t_n) => e *)
  | Rec of name * tp * exp            (* rec (f: t) => e *)
  | Let of name * exp * exp           (* let x = e1 in e2 end *)
  | Apply of exp * (exp list)         (* e (e_1, e_2, ..., e_n) *)
  | Var of name                       (* x *)

(* Deletes every occurence of the elements of xs from l.
   e.g. delete [w; y] [y; x; y; z; w] = [x; z]
*)
let delete (xs : 'a list) (l : 'a list) : 'a list =
  List.filter (fun x -> not (List.mem x xs)) l

(* Fresh variable generator *)
type gen_var = {
  fresh: name -> name;
  reset : unit -> unit
}

let gen_var : gen_var =
  let counter = ref 0 in
  let fresh x = incr counter; x ^ (string_of_int (!counter)) in
  let reset () = counter := 0 in
  {fresh; reset}

let freshVar = gen_var.fresh
let resetCtr = gen_var.reset

(* PART 3: subst *)

(* Question 1: free_variables *)
let rec free_variables : exp -> name list =
  let union l1 l2 = delete l2 l1 @ l2 in
  let union_fvs es =
    List.fold_left (fun acc exp -> union acc (free_variables exp)) [] es
  in
  function
  | Var y -> [y]
  | I _ | B _ -> []
  | If(e, e1, e2) -> union_fvs [e; e1; e2]
  | Primop (_, args) -> union_fvs args
  | Fn (xs, e) ->
      let names = List.map fst xs in
      delete names (free_variables e)  (* TODO: Implement the function. *)
  | Rec (x, _, e) ->
      delete [x] (free_variables e)  (* TODO: Implement the function. *)
  | Let (x, e1, e2) ->
      union (free_variables e1) (delete [x] (free_variables e2))  (* TODO: Implement the function. *)
  | Apply (e, es) ->
      union_fvs (e :: es)  (* TODO: Implement the function. *)

(* Question 2: unused_vars *)
let rec unused_vars =
  function
  | Var _ | I _ | B _ -> []
  | If (e, e1, e2) -> unused_vars e @ unused_vars e1 @ unused_vars e2
  | Primop (_, args) ->
      List.fold_left (fun acc exp -> acc @ unused_vars exp) [] args
  | Let (x, e1, e2) ->
      let unused = unused_vars e1 @ unused_vars e2 in
      if List.mem x (free_variables e2) then
        unused
      else
        x :: unused
  | Rec (x, _, e) ->
      let u = unused_vars e in
      if List.mem x (free_variables e) then u else x :: u  (* TODO: Implement the function. *)
  | Fn (xs, e) ->
      let u = unused_vars e in
      let bound = List.map fst xs in
      let unused_params = List.filter (fun y -> not (List.mem y (free_variables e))) bound in
      u @ unused_params  (* TODO: Implement the function. *)
  | Apply (e, es) ->
      unused_vars e @ (List.fold_left (fun acc exp -> acc @ unused_vars exp) [] es)  (* TODO: Implement the function. *)

(* Question 3: subst *)
let rec subst ((e', x) as s) exp =
  match exp with
  | Var y ->
      if x = y then e'
      else Var y
  | I n -> I n
  | B b -> B b
  | Primop (po, args) ->
      Primop (po, List.map (subst s) args)
  | If (e, e1, e2) ->
      If (subst s e, subst s e1, subst s e2)
  | Let (y, e1, e2) ->
      let e1' = subst s e1 in
      if y = x then
        Let (y, e1', e2)
      else
        let (y, e2) =
          if List.mem y (free_variables e') then
            rename y e2
          else
            (y, e2)
        in
        Let (y, e1', subst s e2)
  | Rec (y, t, e) ->
      if y = x then
        Rec (y, t, e)
      else
        let (y, e) =
          if List.mem y (free_variables e') then
            rename y e
          else
            (y, e)
        in
        Rec (y, t, subst s e)  (* TODO: Implement the function. *)
  | Fn (xs, e) ->
      if List.exists (fun (y, _) -> y = x) xs then
        Fn (xs, e)
      else
        let (new_params, new_e) =
          List.fold_left
            (fun (acc_params, acc_body) (n, t) ->
               if List.mem n (free_variables e') then
                 let (n', acc_body') = rename n acc_body in
                 (acc_params @ [(n', t)], acc_body')
               else
                 (acc_params @ [(n, t)], acc_body)
            ) ([], e) xs
        in
        Fn (new_params, subst s new_e)  (* TODO: Implement the function. *)
  | Apply (e, es) ->
      Apply (subst s e, List.map (subst s) es)  (* TODO: Implement the function. *)

and rename x e =
  let x' = freshVar x in
  (x', subst (Var x', x) e)

and rename_all names exp =
  List.fold_right
    (fun name (names, exp) ->
       let (name', exp') = rename name exp in
       (name' :: names, exp'))
    names
    ([], exp)

(* Applying a list of substitutions to an expression, leftmost first *)
let subst_list subs exp =
  List.fold_left (fun exp sub -> subst sub exp) exp subs

(* The rest of the prelude (string_of_tp, print_exp, etc.) is omitted for brevity. *)