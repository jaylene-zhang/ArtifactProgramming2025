exception NotImplemented

(* Types in MiniCAML *)
type tp =
  | Arrow of tp list * tp   (* function type: S1 S2 ... Sn -> T *)
  | Int
  | Bool

(* Used for variables, aka "identifiers" *)
type name = string

(* The primitive operations available in MiniCAML *)
type primop = Equals | LessThan | Plus | Minus | Times | Negate

(* Expressions in MiniCAML *)
type exp =
  | I of int                          
  | B of bool                         
  | If of exp * exp * exp             
  | Primop of primop * exp list       
  | Fn of (name * tp) list * exp      
  | Rec of name * tp * exp            
  | Let of name * exp * exp           
  | Apply of exp * (exp list)         
  | Var of name                       

let ex1 : exp =
  Fn ([("x", Int); ("y", Int)],
      Primop (Plus,
              [Primop (Times, [Var "x"; Var "x"]);
               Primop (Times, [Var "y"; Var "y"])]))

let ex2 : exp = Fn ([], B true)

let ex3 : exp =
  Let ("f", ex1,
       Apply (Var "f", [I 3; I 4]))

let ex4 : exp =
  Let ("g", ex2,
       Apply (Var "g", []))

let ex5 : exp =
  Let ("f", ex1,
       Apply (Var "f", [I 3]))

let ex6 : exp =
  Let ("f",
       Fn ([("x", Int)],
           Fn ([("y", Int)],
               Primop (Plus,
                       [Primop (Times, [Var "x"; Var "x"]);
                        Primop (Times, [Var "y"; Var "y"])]))),
       Apply (Apply (Var "f", [I 3]),
              [I 4]))

let ex7 : exp =
  Let ("f",
       Fn ([("x", Int)],
           Fn ([("y", Int)],
               Primop (Plus,
                       [Primop (Times, [Var "x"; Var "x"]);
                        Primop (Times, [Var "y"; Var "y"])]))),
       Apply (Var "f", [I 3; I 4]))

let delete (xs : 'a list) (l : 'a list) : 'a list =
  List.filter (fun x -> not (List.mem x xs)) l

type subst = exp * name

type gen_var = {
  fresh: name -> name;
  reset : unit -> unit
}

let gen_var : gen_var =
  let counter = ref 0 in
  let fresh x = incr counter; x ^ (string_of_int (!counter)) in
  let reset () = counter := 0 in
  {fresh; reset}

let freshVar = gen_var.fresh
let resetCtr = gen_var.reset

let rec string_of_tp t = match t with
  | Arrow (t1s, t2) ->
      (String.concat ", " (List.map string_of_tp t1s)) ^ " -> " ^ string_of_tp t2
  | Int -> "int"
  | Bool -> "bool"

let nl_sep l = String.concat "\n" l
let bracket str = "(" ^ str ^ ")"

let string_of_op p = match p with
  | Equals   -> " = "
  | LessThan -> " < "
  | Plus     -> " + "
  | Minus    -> " - "
  | Times    -> " * "
  | Negate   -> "-"

let rec string_of_exp indent exp =
  let new_ind = indent ^ "  " in
  let string_of_exp' = string_of_exp indent in
  let string_of_exp'' = string_of_exp new_ind in
  match exp with
  | I n ->
      if n < 0 then bracket (string_of_int n)
      else string_of_int n
  | B b -> if b then "True" else "False"
  | If (p, e1, e2) ->
      nl_sep
        ["if " ^ (string_of_exp'' p) ^ " then";
         new_ind ^ (string_of_exp'' e1);
         indent ^ "else";
         new_ind ^ (string_of_exp'' e2)]
  | Primop (p, el) ->
      bracket @@
      if p = Negate then
        (string_of_op p) ^ (string_of_exp' (List.nth el 0))
      else
        (string_of_exp' (List.nth el 0)) ^
        (string_of_op p) ^
        (string_of_exp' (List.nth el 1))
  | Fn (xs, exp) ->
      let params =
        String.concat ", "
          (List.map (fun (x, tp) -> x ^ ": " ^ (string_of_tp tp)) xs)
      in
      bracket @@
      nl_sep
        ["fun (" ^ params ^ ") =>";
         new_ind ^ (string_of_exp'' exp)]
  | Rec (name, tp, exp) ->
      bracket @@
      nl_sep
        ["rec (" ^ name ^ ": " ^ (string_of_tp tp) ^ ") =>";
         new_ind ^ (string_of_exp'' exp)]
  | Let (name, e1, e2) ->
      nl_sep
        ["let " ^ name ^ " = " ^ (string_of_exp' e1) ^ " in";
         new_ind ^ (string_of_exp'' e2)]
  | Apply (e, es) ->
      let params = bracket (String.concat ", " (List.map string_of_exp' es)) in
      (string_of_exp' e) ^ " " ^ params
  | Var name -> name

let print_exp exp = print_string (string_of_exp "" exp)

(* free_variables *)
let rec free_variables : exp -> name list =
  let union l1 l2 = delete l2 l1 @ l2 in
  let union_fvs es =
    List.fold_left (fun acc exp -> union acc (free_variables exp)) [] es
  in
  function
  | Var y -> [y]
  | I _ | B _ -> []
  | If(e, e1, e2) -> union_fvs [e; e1; e2]
  | Primop (_, args) -> union_fvs args
  | Fn (xs, e) ->
      let vs = List.map fst xs in
      delete vs (free_variables e)
  | Rec (x, _, e) ->
      delete [x] (free_variables e)
  | Let (x, e1, e2) ->
      let fvs_e1 = free_variables e1 in
      let fvs_e2 = free_variables e2 in
      union fvs_e1 (delete [x] fvs_e2)
  | Apply (e, es) ->
      union_fvs (e :: es)

(* unused_vars *)
let rec unused_vars =
  function
  | Var _ | I _ | B _ -> []
  | If (e, e1, e2) -> unused_vars e @ unused_vars e1 @ unused_vars e2
  | Primop (_, args) ->
      List.fold_left (fun acc exp -> acc @ unused_vars exp) [] args
  | Let (x, e1, e2) ->
      let unused = unused_vars e1 @ unused_vars e2 in
      if List.mem x (free_variables e2) then
        unused
      else
        x :: unused
  | Rec (x, _, e) ->
      let uv = unused_vars e in
      if List.mem x (free_variables e) then uv else x :: uv
  | Fn (xs, e) ->
      let uv = unused_vars e in
      let fvs = free_variables e in
      let xs_unused = List.filter (fun v -> not (List.mem v fvs)) (List.map fst xs) in
      xs_unused @ uv
  | Apply (e, es) ->
      let uv_e = unused_vars e in
      let uv_es = List.fold_left (fun acc e' -> acc @ unused_vars e') [] es in
      uv_e @ uv_es

(* subst *)
let rec subst ((e', x) as s) exp =
  match exp with
  | Var y ->
      if x = y then e'
      else Var y
  | I n -> I n
  | B b -> B b
  | Primop (po, args) -> Primop (po, List.map (subst s) args)
  | If (e, e1, e2) ->
      If (subst s e, subst s e1, subst s e2)
  | Let (y, e1, e2) ->
      let e1' = subst s e1 in
      if y = x then
        Let (y, e1', e2)
      else
        let (y, e2) =
          if List.mem y (free_variables e') then
            rename y e2
          else
            (y, e2)
        in
        Let (y, e1', subst s e2)
  | Rec (y, t, e1) ->
      if y = x then Rec(y, t, e1)
      else
        let (y, e1) =
          if List.mem y (free_variables e') then
            rename y e1
          else
            (y, e1)
        in
        Rec(y, t, subst s e1)
  | Fn (xs, e1) ->
      let vs = List.map fst xs in
      if List.mem x vs then Fn(xs, e1)
      else
        let fvs_e' = free_variables e' in
        let to_rename = List.filter (fun v -> List.mem v fvs_e') vs in
        let (vs', e1') = rename_all to_rename e1 in
        let rec pair_up oldxs newvs =
          match oldxs, newvs with
          | [], [] -> []
          | (o, t)::resto, n::restn -> (n, t) :: pair_up resto restn
          | _, _ -> failwith "pairUp mismatch"
        in
        Fn(pair_up xs vs', subst s e1')
  | Apply (e, es) ->
      Apply(subst s e, List.map (subst s) es)

and rename x e =
  let x' = freshVar x in
  (x', subst (Var x', x) e)

and rename_all names exp =
  List.fold_right
    (fun name (names_acc, exp_acc) ->
       let (name', exp') = rename name exp_acc in
       (name' :: names_acc, exp'))
    names
    ([], exp)

let subst_list subs exp =
  List.fold_left (fun exp sub -> subst sub exp) exp subs