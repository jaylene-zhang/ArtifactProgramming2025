```ocaml
(* TODO: Implement the missing cases of free_variables. *)
let rec free_variables : exp -> name list =
  let union l1 l2 = delete l2 l1 @ l2 in
  let union_fvs es = List.fold_left (fun acc exp -> union acc (free_variables exp)) [] es in
  function
  | Var y -> [y]
  | I _ | B _ -> []
  | If(e, e1, e2) -> union_fvs [e; e1; e2]
  | Primop (_, args) -> union_fvs args
  | Fn (xs, e) ->
      let fvs_e = free_variables e in
      delete (List.map fst xs) fvs_e
  | Rec (x, _, e) ->
      let fvs_e = free_variables e in
      delete [x] fvs_e
  | Let (x, e1, e2) ->
      let fvs_e1 = free_variables e1 in
      let fvs_e2 = free_variables e2 in
      union (delete [x] fvs_e1) fvs_e2
  | Apply (e, es) -> union (free_variables e) (union_fvs es)

(* TODO: Implement the missing cases of unused_vars. *)
let rec unused_vars =
  function
  | Var _ | I _ | B _ -> []
  | If (e, e1, e2) -> unused_vars e @ unused_vars e1 @ unused_vars e2
  | Primop (_, args) ->
      List.fold_left (fun acc exp -> acc @ unused_vars exp) [] args
  | Let (x, e1, e2) ->
      let unused = unused_vars e1 @ unused_vars e2 in
      if List.mem x (free_variables e2) then
        unused
      else
        x :: unused
  | Rec (x, _, e) ->
      let unused = unused_vars e in
      if List.mem x (free_variables e) then
        unused
      else
        x :: unused
  | Fn (xs, e) ->
      let unused = unused_vars e in
      let bound_vars = List.map fst xs in
      List.filter (fun v -> not (List.mem v bound_vars)) unused
  | Apply (e, es) -> unused_vars e @ List.flatten (List.map unused_vars es)

(* TODO: Implement the missing cases of subst. *)
let rec subst ((e', x) as s) exp =
  match exp with
  | Var y ->
      if x = y then e'
      else Var y
  | I n -> I n
  | B b -> B b
  | Primop (po, args) -> Primop (po, List.map (subst s) args)
  | If (e, e1, e2) ->
      If (subst s e, subst s e1, subst s e2)
  | Let (y, e1, e2) ->
      let e1' = subst s e1 in
      if y = x then
        Let (y, e1', e2)
      else
        let (y, e2) =
          if List.mem y (free_variables e') then
            rename y e2
          else
            (y, e2)
        in
        Let (y, e1', subst s e2)
  | Rec (y, t, e) ->
      if y = x then
        Rec (y, t, e)
      else
        let (y', e) =
          if List.mem y (free_variables e') then
            rename y e
          else
            (y, e)
        in
        Rec (y', t, subst (e', x) e)
  | Fn (xs, e) ->
      let (bs, e) = rename_all (List.map fst xs) e in
      let e' = subst (e', x) e in
      Fn (bs, e')
  | Apply (e, es) ->
      Apply (subst s e, List.map (subst s) es)

and rename x e =
  let x' = freshVar x in
  (x', subst (Var x', x) e)

and rename_all names exp =
  List.fold_right
    (fun name (names, exp) ->
       let (name', exp') = rename name exp in
       (name' :: names, exp'))
    names
    ([], exp)

(* Applying a list of substitutions to an expression, leftmost first *)
let subst_list subs exp =
  List.fold_left (fun exp sub -> subst sub exp) exp subs
```