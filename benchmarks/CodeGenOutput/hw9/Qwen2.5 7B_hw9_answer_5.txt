let rec subst ((e', x) as s) exp =
  match exp with
  | Var y ->
      if x = y then e'
      else Var y
  | I n -> I n
  | B b -> B b
  | Primop (po, args) -> Primop (po, List.map (subst s) args)
  | If (e, e1, e2) ->
      If (subst s e, subst s e1, subst s e2)
  | Let (y, e1, e2) ->
      let e1' = subst s e1 in
      if y = x then
        Let (y, e1', e2)
      else
        let (y', e2') = rename y e2 in
        Let (y', e1', subst s (Var y'))
  | Rec (f, t, e) ->
      let f' = freshVar f in
      let e' = subst (Var f', f) e in
      Rec (f', t, e')
  | Fn (vars, body) ->
      let vars' =
        List.map
          (fun (y, tp) ->
             let y' = freshVar y in
             (y', tp))
          vars
      in
      let body' = subst s body in
      Fn (vars', body')
  | Apply (e, es) ->
      let e' = subst s e in
      let es' = List.map (subst s) es in
      Apply (e', es')
and rename x e =
  let x' = freshVar x in
  (x', subst (Var x', x) e)

and rename_all names exp =
  List.fold_right
    (fun name (names, exp) ->
       let (name', exp') = rename name exp in
       (name' :: names, exp'))
    names
    ([], exp)

(* Applying a list of substitutions to an expression, leftmost first *)
let subst_list subs exp =
  List.fold_left (fun exp sub -> subst sub exp) exp subs