exception NotImplemented

type tp =
  | Arrow of tp list * tp  (* function type: S1 S2 ... Sn -> T *)
  | Int
  | Bool

type name = string

type primop = Equals | LessThan | Plus | Minus | Times | Negate

type exp =
  | I of int                          (* 0 | 1 | 2 | ... *)
  | B of bool                         (* true | false *)
  | If of exp * exp * exp             (* if e then e1 else e2 *)
  | Primop of primop * exp list       (* e1 <op> e2  or <op> e *)
  | Fn of (name * tp) list * exp      (* fn (x1 : t1, ..., xn : tn) => e *)
  | Rec of name * tp * exp            (* rec (f : t) => e *)
  | Let of name * exp * exp           (* let x = e1 in e2 end *)
  | Apply of exp * exp list           (* e (e1, e2, ..., en) *)
  | Var of name                       (* x *)

(* Example programs *)
let ex1 : exp =
  Fn ([("x", Int); ("y", Int)],
      Primop (Plus,
              [Primop (Times, [Var "x"; Var "x"]);
               Primop (Times, [Var "y"; Var "y"])]))

let ex2 : exp = Fn ([], B true)

let ex3 : exp =
  Let ("f", ex1,
       Apply (Var "f", [I 3; I 4]))

let ex4 : exp =
  Let ("g", ex2,
       Apply (Var "g", []))

let ex5 : exp =
  Let ("f", ex1,
       Apply (Var "f", [I 3]))

let ex6 : exp =
  Let ("f",
       Fn ([("x", Int)],
           Fn ([("y", Int)],
               Primop (Plus,
                       [Primop (Times, [Var "x"; Var "x"]);
                        Primop (Times, [Var "y"; Var "y"])]))),
       Apply (Apply (Var "f", [I 3]),
              [I 4]))

let ex7 : exp =
  Let ("f",
       Fn ([("x", Int)],
           Fn ([("y", Int)],
               Primop (Plus,
                       [Primop (Times, [Var "x"; Var "x"]);
                        Primop (Times, [Var "y"; Var "y"])]))),
       Apply (Var "f", [I 3; I 4]))

(* Deletes every occurence of the elements of xs from l. *)
let delete (xs : 'a list) (l : 'a list) : 'a list =
  List.filter (fun x -> not (List.mem x xs)) l

(* Generating fresh variables *)
type gen_var = {
  fresh: name -> name; (* generates a fresh name based on a given one. *)
  reset : unit -> unit   (* resets the internal counter for making names. *)
}

let gen_var : gen_var =
  let counter = ref 0 in
  let fresh x = incr counter; x ^ (string_of_int (!counter)) in
  let reset () = counter := 0 in
  {fresh; reset}

let freshVar = gen_var.fresh
let resetCtr = gen_var.reset

let rec string_of_tp t = match t with
  | Arrow (t1s, t2) ->
      (String.concat ", " (List.map string_of_tp t1s)) ^
      " -> " ^
      string_of_tp t2
  | Int -> "int"
  | Bool -> "bool"

let nl_sep l = String.concat "\n" l

let bracket str = "(" ^ str ^ ")"

let string_of_op p = match p with
  | Equals   -> " = "
  | LessThan -> " < "
  | Plus     -> " + "
  | Minus    -> " - "
  | Times    -> " * "
  | Negate   -> "-"

let rec string_of_exp indent exp =
  let new_ind = indent ^ "  " in
  let string_of_exp' = string_of_exp indent in
  let string_of_exp'' = string_of_exp new_ind in
  match exp with
  | I n ->
      if n < 0 then bracket (string_of_int n)
      else string_of_int n
  | B b -> if b then "True" else "False"
  | If (p, e1, e2) ->
      nl_sep
        ["if " ^ (string_of_exp'' p) ^ " then";
         new_ind ^ (string_of_exp'' e1);
         indent ^ "else";
         new_ind ^ (string_of_exp'' e2)]
  | Primop (p, el) ->
      bracket @@
      if p = Negate then
        (string_of_op p) ^ (string_of_exp' (List.nth el 0))
      else
        (string_of_exp' (List.nth el 0)) ^
        (string_of_op p) ^
        (string_of_exp' (List.nth el 1))
  | Fn (xs, exp) ->
      let params =
        String.concat ", "
          (List.map (fun (x, tp) -> x ^ ": " ^ (string_of_tp tp)) xs)
      in
      bracket @@
      nl_sep
        ["fun (" ^ params ^ ") =>";
         new_ind ^ (string_of_exp'' exp)]
  | Rec (name, tp, exp) ->
      bracket @@
      nl_sep
        ["rec (" ^ name ^ ": " ^ (string_of_tp tp) ^ ") =>";
         new_ind ^ (string_of_exp'' exp)]
  | Let (name, e1, e2) ->
      nl_sep
        ["let " ^ name ^ " = " ^ (string_of_exp' e1) ^ " in";
         new_ind ^ (string_of_exp'' e2)]
  | Apply (e, es) ->
      let params = bracket (String.concat ", " (List.map string_of_exp' es)) in
      (string_of_exp' e) ^ " " ^ params
  | Var name -> name

let print_exp exp = print_string (string_of_exp "" exp)

(* Question 1: free_variables *)

let rec free_variables : exp -> name list =
  let union l1 l2 = delete l2 l1 @ l2 in
  let union_fvs es =
    List.fold_left (fun acc exp -> union acc (free_variables exp)) [] es
  in
  function
  | Var y -> [y]
  | I _ | B _ -> []
  | If (e, e1, e2) -> union_fvs [e; e1; e2]
  | Primop (_, args) -> union_fvs args
  | Fn (xs, e) ->
      let bound_names = List.map fst xs in
      delete bound_names (free_variables e)  (* TODO: Implement the function. *)
  | Rec (x, _, e) ->
      delete [x] (free_variables e)  (* TODO: Implement the function. *)
  | Let (x, e1, e2) ->
      let fv_e1 = free_variables e1 in
      let fv_e2 = free_variables e2 in
      union fv_e1 (delete [x] fv_e2)  (* TODO: Implement the function. *)
  | Apply (e, es) ->
      union (free_variables e) (union_fvs es)  (* TODO: Implement the function. *)

(* Helper function for checking variable occurrences *)
let rec occurs x exp =
  match exp with
  | Var y -> x = y
  | I _ -> false
  | B _ -> false
  | If (e, e1, e2) -> occurs x e || occurs x e1 || occurs x e2
  | Primop (_, args) -> List.exists (occurs x) args
  | Let (y, e1, e2) -> occurs x e1 || (if x = y then false else occurs x e2)
  | Rec (y, _, e) -> if x = y then false else occurs x e
  | Fn (args, e) -> if List.exists (fun (y, _) -> y = x) args then false else occurs x e
  | Apply (e, es) -> occurs x e || List.exists (occurs x) es

(* Question 2: unused_vars *)

let rec unused_vars =
  function
  | Var _ | I _ | B _ -> []
  | If (e, e1, e2) -> unused_vars e @ unused_vars e1 @ unused_vars e2
  | Primop (_, args) ->
      List.fold_left (fun acc exp -> acc @ unused_vars exp) [] args
  | Let (x, e1, e2) ->
      let unused = unused_vars e1 @ unused_vars e2 in
      if List.mem x (free_variables e2) then
        unused
      else
        x :: unused
  | Rec (x, _, e) ->
      let u = unused_vars e in
      if occurs x e then u else x :: u  (* TODO: Implement the function. *)
  | Fn (xs, e) ->
      let param_names = List.map fst xs in
      let unused_params =
        List.fold_right (fun x acc -> if occurs x e then acc else x :: acc) param_names []
      in
      unused_params @ unused_vars e  (* TODO: Implement the function. *)
  | Apply (e, es) ->
      unused_vars e @ List.fold_left (fun acc exp -> acc @ unused_vars exp) [] es  (* TODO: Implement the function. *)

(* Question 3: subst *)

let rec subst ((e', x) as s) exp =
  match exp with
  | Var y ->
      if x = y then e'
      else Var y
  | I n -> I n
  | B b -> B b
  | Primop (po, args) -> Primop (po, List.map (subst s) args)
  | If (e, e1, e2) ->
      If (subst s e, subst s e1, subst s e2)
  | Let (y, e1, e2) ->
      let e1' = subst s e1 in
      if y = x then
        Let (y, e1', e2)
      else
        let (y, e2) =
          if List.mem y (free_variables e') then
            rename y e2
          else
            (y, e2)
        in
        Let (y, e1', subst s e2)
  | Rec (y, t, e) ->
      if y = x then Rec (y, t, e)
      else
        let e'' =
          if List.mem y (free_variables e') then
            let (y', e_renamed) = rename y e in
            e_renamed
          else e
        in
        Rec (y, t, subst s e'')  (* TODO: Implement the function. *)
  | Fn (xs, e) ->
      if List.exists (fun (y, _) -> y = x) xs then
        Fn (xs, e)
      else
        let names_to_rename = List.filter (fun y -> List.mem y (free_variables e')) (List.map fst xs) in
        if names_to_rename = [] then
          Fn (xs, subst s e)
        else
          let (renamed_names, e_renamed) = rename_all names_to_rename e in
          let mapping = List.combine names_to_rename renamed_names in
          let new_xs =
            List.map (fun (y, t) ->
              try (List.assoc y mapping, t) with Not_found -> (y, t)
            ) xs
          in
          Fn (new_xs, subst s e_renamed)  (* TODO: Implement the function. *)
  | Apply (e, es) ->
      Apply (subst s e, List.map (subst s) es)  (* TODO: Implement the function. *)

and rename x e =
  let x' = freshVar x in
  (x', subst (Var x', x) e)

and rename_all names exp =
  List.fold_right
    (fun name (names_acc, exp_acc) ->
       let (name', exp') = rename name exp_acc in
       (name' :: names_acc, exp'))
    names
    ([], exp)

let subst_list subs exp =
  List.fold_left (fun exp sub -> subst sub exp) exp subs