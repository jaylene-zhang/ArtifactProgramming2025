```ocaml
(* TODO: Implement the function. *)
let collect_variables (formula : formula) : Variable_set.t =
  let rec aux f =
    match f with
    | Variable v -> Variable_set.singleton v
    | Conjunction (f1, f2) -> Variable_set.union (aux f1) (aux f2)
    | Disjunction (f1, f2) -> Variable_set.union (aux f1) (aux f2)
    | Negation f1 -> aux f1
  in
  aux formula

(* TODO: Implement the function. *)
let eval (state : truth_assignment) (formula : formula) : bool =
  let rec eval_aux f =
    match f with
    | Variable v -> (
        match Variable_map.find_opt v state with
        | Some value -> value
        | None -> raise (Unassigned_variable v))
    | Conjunction (f1, f2) -> eval_aux f1 && eval_aux f2
    | Disjunction (f1, f2) -> eval_aux f1 || eval_aux f2
    | Negation f1 -> not (eval_aux f1)
  in
  eval_aux formula

(* TODO: Implement the function. *)
let find_satisfying_assignment (formula : formula) : truth_assignment =
  let vars = collect_variables formula |> Variable_set.elements in
  let rec backtrack assignments remaining_vars =
    match remaining_vars with
    | [] -> if eval assignments formula then assignments else raise Unsatisfiable_formula
    | var :: rest ->
        try backtrack (Variable_map.add var true assignments) rest
        with Unsatisfiable_formula ->
          backtrack (Variable_map.add var false assignments) rest
  in
  backtrack Variable_map.empty vars
```