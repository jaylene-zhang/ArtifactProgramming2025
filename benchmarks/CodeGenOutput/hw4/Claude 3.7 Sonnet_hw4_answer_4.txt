let rec collect_variables (formula : formula) : Variable_set.t =
  match formula with
  | Variable x -> Variable_set.singleton x
  | Conjunction (f1, f2) -> 
      Variable_set.union (collect_variables f1) (collect_variables f2)
  | Disjunction (f1, f2) -> 
      Variable_set.union (collect_variables f1) (collect_variables f2)
  | Negation f -> collect_variables f

exception Unassigned_variable of string

let rec eval (state : truth_assignment) (formula : formula) : bool =
  match formula with
  | Variable x -> 
      (match Variable_map.find_opt x state with
       | Some b -> b
       | None -> raise (Unassigned_variable x))
  | Conjunction (f1, f2) -> (eval state f1) && (eval state f2)
  | Disjunction (f1, f2) -> (eval state f1) || (eval state f2)
  | Negation f -> not (eval state f)

exception Unsatisfiable_formula
exception Found of truth_assignment

let find_satisfying_assignment (formula : formula) : truth_assignment =
  let vars = variable_set_to_list (collect_variables formula) in
  
  let rec try_assignments partial_assignment remaining_vars =
    match remaining_vars with
    | [] -> 
        if eval partial_assignment formula then
          raise (Found partial_assignment)
        else
          ()
    | var :: rest ->
        let with_true = Variable_map.add var true partial_assignment in
        let with_false = Variable_map.add var false partial_assignment in
        (try try_assignments with_true rest with _ -> ());
        (try try_assignments with_false rest with _ -> ())
  in
  
  try
    try_assignments Variable_map.empty vars;
    raise Unsatisfiable_formula
  with
    | Found assignment -> assignment