### Implementing the Functions

#### Collecting Variables
```ocaml
let rec collect_variables (formula : formula) : Variable_set.t =
  match formula with
  | Variable var -> Variable_set.singleton var
  | Conjunction (f1, f2) -> Variable_set.union (collect_variables f1) (collect_variables f2)
  | Disjunction (f1, f2) -> Variable_set.union (collect_variables f1) (collect_variables f2)
  | Negation f -> collect_variables f
```

#### Evaluating a Formula
```ocaml
let rec eval (state : truth_assignment) (formula : formula) : bool =
  match formula with
  | Variable var ->
    (match Variable_map.find_opt var state with
     | Some b -> b
     | None -> raise (Unassigned_variable var))
  | Conjunction (f1, f2) -> (eval state f1) && (eval state f2)
  | Disjunction (f1, f2) -> (eval state f1) || (eval state f2)
  | Negation f -> not (eval state f)
```

#### Finding a Satisfying Assignment
```ocaml
let find_satisfying_assignment (formula : formula) : truth_assignment =
  let vars = collect_variables formula in
  let var_list = Variable_set.elements vars in
  let rec try_assignments (formula : formula) (vars_left : string list) (current_assign : truth_assignment) : truth_assignment =
    match vars_left with
    | [] ->
      if eval current_assign formula then current_assign
      else raise Unsatisfiable_formula
    | var :: rest ->
      try
        let new_assign = Variable_map.add var true current_assign in
        try_assignments formula rest new_assign
      with
      | Unsatisfiable_formula ->
        let new_assign = Variable_map.add var false current_assign in
        try_assignments formula rest new_assign
  in
  try_assignments formula var_list Variable_map.empty
```