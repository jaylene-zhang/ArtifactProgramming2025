```ocaml
(* TODO: Implement the function. *)
let collect_variables (formula : formula) : Variable_set.t =
  match formula with
  | Variable x -> Variable_set.singleton x
  | Conjunction (f1, f2) -> Variable_set.union (collect_variables f1) (collect_variables f2)
  | Disjunction (f1, f2) -> Variable_set.union (collect_variables f1) (collect_variables f2)
  | Negation f -> collect_variables f

(* TODO: Implement the function. *)
let eval (state : truth_assignment) (formula : formula) : bool =
  match formula with
  | Variable x ->
      (match Variable_map.find_opt x state with
      | Some value -> value
      | None -> raise (Unassigned_variable x))
  | Conjunction (f1, f2) -> (eval state f1) && (eval state f2)
  | Disjunction (f1, f2) -> (eval state f1) || (eval state f2)
  | Negation f -> not (eval state f)

(* TODO: Implement the function. *)
let rec find_satisfying_assignment (formula : formula) : truth_assignment =
  let vars = collect_variables formula in
  let var_list = Variable_set.elements vars in
  let rec try_assignment assignment vars =
    match vars with
    | [] -> if eval assignment formula then Some assignment else None
    | var :: rest ->
        (match try_assignment (Variable_map.add var true assignment) rest with
        | Some result -> Some result
        | None -> try_assignment (Variable_map.add var false assignment) rest)
  in
  match try_assignment Variable_map.empty var_list with
  | Some result -> result
  | None -> raise Unsatisfiable_formula
```