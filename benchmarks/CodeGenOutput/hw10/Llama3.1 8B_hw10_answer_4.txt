Here are the completed code for the missing cases of the function `eval`, `infer`, and `unify`:

```ocaml
(* eval *)
let rec eval exp =
  match exp with
  | I _ -> exp
  | B _ -> exp
  | Fn (xs, e) -> eval e (* TODO: Implement this case *)
  | Var x -> raise (Stuck (Free_variable x))
  | Primop (po, args) ->
      let args = List.map eval args in
      begin
        match eval_op po args with
        | None -> raise (Stuck Bad_primop_args)
        | Some v -> v
      end
  | If (e, e1, e2) ->
      begin
        match eval e with
        | B true -> eval e1
        | B false -> eval e2
        | _ -> raise (Stuck If_non_true_false)
      end
  | Let (x, e1, e2) ->
      let e1 = eval e1 in
      eval (subst (e1, x) e2)
  | Rec (f, _, e) ->
      let v = eval e in
      eval (subst_list [(v, f)] (TermTerm "_", TPVar f))
  | Apply (e, es) ->
      let v = eval e in
      match v with
      | Fn (xs, e') ->
          let ts = List.map infer (List.map (fun e -> Var (List.nth xs (List.length es))) es) in
          eval (List.fold_left (fun acc e -> subst_list [(e, List.nth xs (List.length acc))] acc) es e')
      | _ -> raise (Stuck Apply_non_fn)

  | UArrow (t1, t2) -> raise (Stuck Bad_arrow_type)

(* infer *)
let rec infer ctx e =
  match e with
  | Var x ->
      begin
        try lookup x ctx
        with Not_found -> raise (TypeError (Free_variable x))
      end
  | I _ -> Int
  | B _ -> Bool

  | Fn (xs, e) ->
      let ts = List.map (fun ts -> Param (...)) xs in
      let t = infer (List.fold_left (fun ctx (t, x) -> extend ctx (x, t)) ctx ts) e in
      Arrow ts t

  | Primop (po, exps) ->
      let (domain, range) = primopType po in
      check ctx exps domain range

  | If (e, e1, e2) ->
      begin
        match infer ctx e with
        | Bool ->
            let t1 = infer ctx e1 in
            let t2 = infer ctx e2 in
            if t1 = t2 then t1
            else type_mismatch t1 t2
        | t -> type_mismatch Bool t
      end

  | Let (x, e1, e2) ->
      let t1 = infer ctx e1 in
      infer (extend ctx (x, t1)) e2

  | Rec (f, _, e) ->
      let t = infer (extend_ctx ctx (f, Arrow (Param (Int), TPVar f))) e in
      Arrow (Param (Int), t)

  | Apply (e, es) ->
      let t = infer ctx e in
      match t with
      | Arrow t1 t2 ->
          let ts = List.map (fun e -> infer ctx e) es in
          let t' = ArrowList.concat_map (fun ts -> Param ts) ts t1 in
          if t' = t2 then t2
          else type_mismatch t' t2
      | _ -> raise (TypeError (Apply_non_arrow t'))

  | var xs e -> raise (TypeError (Unbound_var xs))

(* unify *)
let unify : utp -> utp -> utp UTVarMap.t =
  let rec unify (type_substitution : utp UTVarMap.t) (t1 : utp) (t2 : utp) : utp UTVarMap.t =
    match t1, t2 with
    (* Unifying identical concrete types does nothing *)
    | UInt, UInt
    | UBool, UBool -> type_substitution

    | UArrow (t1, t1'), UArrow (t2, t2') -> raise (UnifError (Arity_mismatch))

    | UCross ts1, UCross ts2 ->
        UTVarMap.fold (fun bs ts ->
            raise (UnifError (Same_cross ts1 ts2 (List.map (fun b -> UTVar (B.toString b)) bs))))
          type_substitution
          (fun _ -> List.combine ts1 ts2)

    (* Type substitution for variables *)
    (* If a is bound in t then we must raise an error *)
    | UTVar a, UTVar a' when a = a' ->
        raise (UnifError (Var_equals_itself a))

    | UTVar a, t2 -> unifyVar type_substitution a t2
    | t1, UTVar b -> unifyVar type_substitution b t1

    (* All other cases are mismatched types. *)
    | t1, t2 -> unif_error @@ UnifMismatch (t1, t2)

  (* Unify a variable with a type *)
  and unifyVar (type_substitution : utp UTVarMap.t) (a : string) (t : utp) : utp UTVarMap.t =
    let sub : utp UTVarMap.t option ref = ref None in
    let rec occurs : utp -> bool = function
      | UInt | UBool -> false
      | UArrow (t1, t2) -> occurs t1 || occurs t2
      | UCross ts -> List.exists occurs ts
      | UTVar b -> if a = b then true else
          match UTVarMap.find_opt b !sub with
          | None -> false
          | Some t' -> occurs t'
    in
    if occurs t then raise (UnifError (Var_occurs_in_type a t));
    if !sub <> None then unify (!sub) a t
    else
      begin
        let sub := Some (Map.singleton a t) in
        unify type_substitution a t
      end

  in
  fun t1 t2 -> unify UTVarMap.empty t1 t2
```