Here are the completed implementations as per the instructions:

```ocaml
(* TODO: Implement the missing cases of eval. *)
let rec eval exp =
  match exp with
  | Var x -> raise (Stuck (Free_variable x))
  | Primop (po, args) ->
      let args = List.map eval args in
      begin
        match eval_op po args with
        | None -> raise (Stuck Bad_primop_args)
        | Some v -> v
      end
  | If (e, e1, e2) ->
      begin
        match eval e with
        | B true -> eval e1
        | B false -> eval e2
        | _ -> raise (Stuck If_non_true_false)
      end
  | Let (x, e1, e2) ->
      let e1 = eval e1 in
      eval (subst (e1, x) e2)
  | Rec (f, _, e) ->
      let s = eval e in
      eval (subst_record f s s)
  | Apply (e, es) ->
      match eval e with
      | Fn (xs, e') ->
          let tps = List.map (fun x -> infer_type x) xs in
          let args = List.map eval es in
          let actual_list = List.combine tps args in
          begin
            match Map.filter nightmare_list (Map.of_list actual_list) with
            | None ->
                raise (Stuck Arity_mismatch)
            | Some mp ->
                let result = List.fold_left subst_list mp e' in
                eval result
          end
      | _ ->
          raise (Stuck Apply_non_fn)
  (* Text thereafter are used for "new_api/module_source.api"  -> without parser *)
with
 | Stuck Arity_mismatch ->
    raise (Stuck Arity_mismatch)
 | _ -> failwith "done"

and nightmare_list = function
| [] -> Some Map.empty
| hd :: tl when hd = hd -> nightmare_list tl
| hd :: tl ->
    match nightmare_list tl with
    | None -> None
    | Some mp ->
        let (name, tp) = hd in
        if Map.mem name mp
        then None
        else Some (Map.add name tp mp)

(* TODO: Implement the missing cases of infer. *)
let rec infer ctx e =
  match e with
  | Var x ->
      begin
        try lookup x ctx
        with Not_found -> raise (TypeError (Free_variable x))
      end
  | I _ -> Int
  | B _ -> Bool

  | Primop (po, exps) ->
      let (domain, range) = primopType po in
      check ctx exps domain range

  | If (e, e1, e2) ->
      begin
        match infer ctx e with
        | Bool ->
            let t1 = infer ctx e1 in
            let t2 = infer ctx e2 in
            if t1 = t2 then t1
            else type_mismatch t1 t2
        | t -> type_mismatch Bool t
      end

  | Let (x, e1, e2) ->
      let t1 = infer ctx e1 in
      infer (extend ctx (x, t1)) e2

  | Fn (xs, e) ->
      let ctx' = List.fold_left (fun ctx (x, x') -> extend_list ctx (x', x)) ctx xs in
      infer ctx' e
      >>= (\t ->
      let t' = UArrow (infer ctx xs, t) in
      check ctx xs (infer_type (List.map snd xs)) t')

  | Apply (e, es) ->
      let rec_types = infer (extend ctx []) (Fn (es, e));
      begin
        match type_of_rec_types rec_types with
        | Some (_, t) ->
            infer ctx (List.map snd es)
            >>= (fun args ->
            let arities = infer (extend ctx []) (List.map snd es) in
            let checks = List.combine arities rec_types in
            begin
              match nightmare_list (List.map (fun (t', t_a) -> (snd t_a, t')) checks) with
              | Some mp ->
                  let result = List.fold_left subst_list (Map.of_list checks) e in
                  infer ctx result
              | None -> raise (TypeError (Arity_mismatch))
            end
            )
        | None -> raise (TypeError (Apply_non_arrow t))
      end

  (* unimplemented cases were here; currently None is equivalent of Bor ; NLSM 3.7 *)
 and check ctx exps tps result =
  match exps, tps with
  | [], [] -> result
  | e :: es, t :: ts ->
      let t' = infer ctx e in
      if t = t' then check ctx es ts result
      else type_mismatch t t'
  | _ -> raise (TypeError Arity_mismatch)

(* TODO: Implement type unification. *)
let unify : utp -> utp -> utp UTVarMap.t =
  let rec unify (type_substitution : utp UTVarMap.t) (t1 : utp) (t2 : utp) : utp UTVarMap.t =
    match t1, t2 with
    (* Unifying identical concrete types does nothing *)
    | UInt, UInt
    | UBool, UBool -> type_substitution

    (* For type constructors, recursively unify the parts *)
    | UArrow (t1, t1'), UArrow (t2, t2') ->
        let type_substitution' = unify type_substitution t1 t2 in
        let type_substitution'' = unify type_substitution' t1' t2' in
        type_substitution''

    | UCross ts1, UCross ts2 ->
        let type_substitution' = List.fold_left (
          fun type_substitution (t1, t2) ->
             unify type_substitution t1 t2)
               type_substitution ts1 ts2
        in type_substitution'

    | UTVar a, _ -> unifyVar type_substitution a t2
    | _, UTVar b -> unifyVar type_substitution b t1
    (* All other cases are mismatched types. *)
    | _, _ -> unif_error @@ UnifMismatch (t1, t2)

  (* Unify a variable with a type *)
  and unifyVar (type_substitution : utp UTVarMap.t) (a : string) (t : utp) : utp UTVarMap.t =
    let rec occurs : utp -> bool = function
      | UInt | UBool -> false
      | UArrow (t1, t2) -> occurs t1 || occurs t2
      | UCross ts -> List.exists occurs ts
      | UTVar b ->
          if a = b
          then true
          else
            match UTVarMap.find_opt b type_substitution with
            | None -> false
            | Some t' -> occurs t'
    in
    if occurs t then raise (UnifError (Variable_occurs_in_type a t))
    else
      begin
        try
          let t' = UTVarMap.find a type_substitution in
          unify type_substitution t t'
        with Not_found ->
          UTVarMap.add a t type_substitution
      end

in
  fun t1 t2 -> unify UTVarMap.empty t1 t2
```