let unify : utp -> utp -> utp UTVarMap.t =
  let rec unify (type_substitution : utp UTVarMap.t) (t1 : utp) (t2 : utp) : utp UTVarMap.t =
    match t1, t2 with
    (* Unifying identical concrete types does nothing *)
    | UInt, UInt
    | UBool, UBool -> type_substitution
    | UTVar a, UTVar a' when a = a' -> type_substitution

    (* For type constructors, recursively unify the parts *)
    | UArrow (t1, t1'), UArrow (t2, t2') ->
        let u1 = unify type_substitution t1 t2 in
        let u2 = unify u1 t1' t2' in
        u2

    | UCross ts1, UCross ts2 ->
        let rec cross_unify sub ts1 ts2 =
          match ts1, ts2 with
          | [], [] -> sub
          | t1 :: ts1, t2 :: ts2 ->
              let sub1 = unify sub t1 t2 in
              cross_unify sub1 ts1 ts2
          | _ -> unif_error @@ UnifMismatch (UCross ts1, UCross ts2)
        in
        cross_unify type_substitution ts1 ts2

    | UTVar a, _ -> unifyVar type_substitution a t2
    | _, UTVar b -> unifyVar type_substitution b t1
    (* All other cases are mismatched types. *)
    | _, _ -> unif_error @@ UnifMismatch (t1, t2)

  (* Unify a variable with a type *)
  and unifyVar (type_substitution : utp UTVarMap.t) (a : string) (t : utp) : utp UTVarMap.t =
    let rec occurs : utp -> bool = function
      | UInt | UBool -> false
      | UArrow (t1, t2) -> occurs t1 || occurs t2
      | UCross ts -> List.exists occurs ts
      | UTVar b ->
          if a = b
          then true
          else
            match UTVarMap.find_opt b type_substitution with
            | None -> false
            | Some t' -> occurs t'
    in
    if occurs t then unif_error UnifError
    else
      match UTVarMap.find_opt a type_substitution with
      | None -> UTVarMap.add a t type_substitution
      | Some t' ->
          let u = unify type_substitution t t' in
          UTVarMap.add a (utp_env subst t) u
  in
  fun t1 t2 -> unify UTVarMap.empty t1 t2