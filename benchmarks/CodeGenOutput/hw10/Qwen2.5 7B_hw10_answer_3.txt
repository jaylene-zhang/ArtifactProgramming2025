let unify : utp -> utp -> utp UTVarMap.t =
  let rec unify (type_substitution : utp UTVarMap.t) (t1 : utp) (t2 : utp) : utp UTVarMap.t =
    match t1, t2 with
    (* Unifying identical concrete types does nothing *)
    | UInt, UInt
    | UBool, UBool -> type_substitution
    | UTVar a, UTVar a' when a = a' -> type_substitution

    (* For type constructors, recursively unify the parts *)
    | UArrow (t1, t1'), UArrow (t2, t2') ->
        let type_substitution = unify type_substitution t1 t2 in
        let type_substitution = unify type_substitution t1' t2' in
        type_substitution

    | UCross ts1, UCross ts2 ->
        let cross_unification type_substitution (t1, t2) =
          let type_substitution = unify type_substitution t1 t2 in
          type_substitution
        in
        List.combine ts1 ts2
        |> List.fold_left cross_unification type_substitution

    | UTVar a, _ -> unifyVar type_substitution a t2
    | _, UTVar b -> unifyVar type_substitution b t1
    (* All other cases are mismatched types. *)
    | _, _ -> unif_error @@ UnifMismatch (t1, t2)

  (* Unify a variable with a type *)
  and unifyVar (type_substitution : utp UTVarMap.t) (a : string) (t : utp) : utp UTVarMap.t =
    let rec occurs : utp -> bool = function
      | UInt | UBool -> false
      | UArrow (t1, t2) -> occurs t1 || occurs t2
      | UCross ts -> List.exists occurs ts
      | UTVar b ->
          if a = b
          then true
          else
            match UTVarMap.find_opt b type_substitution with
            | None -> false
            | Some t' -> occurs t'
    in

    if occurs t
    then raise (UnifError ("Circular reference in unification", t))
    else
      match UTVarMap.find_opt a type_substitution with
      | None ->
          UTVarMap.add a t type_substitution
      | Some t' ->
          let type_substitution = unify type_substitution t' t in
          type_substitution

  in
  fun t1 t2 -> unify UTVarMap.empty t1 t2