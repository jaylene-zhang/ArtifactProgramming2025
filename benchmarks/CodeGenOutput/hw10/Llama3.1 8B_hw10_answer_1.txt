Here are the solutions to the problems:

```ocaml
let rec eval exp =
  match exp with
  (* Values evaluate to themselves *)
  | I _ -> exp
  | B _ -> exp
  | Fn _ -> exp

  (* This evaluator is _not_ environment-based. Variables should never
     appear during evaluation since they should be substituted away when
     eliminating binding constructs, e.g. function applications and lets.
     Therefore, if we encounter a variable, we raise an error.
  *)
  | Var x -> raise (Stuck (Free_variable x))

  (* Primitive operations: +, -, *, <, = *)
  | Primop (po, args) ->
      let args = List.map eval args in
      begin
        match eval_op po args with
        | None -> raise (Stuck Bad_primop_args)
        | Some v -> v
      end

  | If (e, e1, e2) ->
      begin
        match eval e with
        | B true -> eval e1
        | B false -> eval e2
        | _ -> raise (Stuck If_non_true_false)
      end

  | Let (x, e1, e2) ->
      let e1 = eval e1 in
      eval (subst (e1, x) e2)

  | Rec (f, _, e) ->
      let f_exp = eval e in
      let t = match f with (_, t, _) -> t in
      let f' = Fn ([t], e in e with f = f_exp) in
      eval (apply f f' [])

  | Apply (e, es) ->
      let t = eval e in
      match t with
      | Fn (xs, _) ->
          let args = List.map eval es in
          if List.length xs = List.length args then
              let e1 = fold_left2 (fun e x t -> apply e (x := t)) t args in
              eval e1
          else raise (Stuck Arity_mismatch)
      | _ -> raise (Stuck Apply_non_fn)

and apply e sub args =
  let rec fold_left2 f e sub args =
    match sub, args with
    | [], [] -> e
    | (x, t) :: sub', y :: args' -> f e x t (fold_left2 f sub' args')
    | _ -> raise (Stuck Arity_mismatch)
  in
  fold_left2 (fun e x t -> subst t x e) e [] args

let rec infer ctx e =
  match e with
  | Var x ->
      begin
        try lookup x ctx
        with Not_found -> raise (TypeError (Free_variable x))
      end
  | I _ -> Int
  | B _ -> Bool

  | Primop (po, exps) ->
      let (domain, range) = primopType po in
      check ctx exps domain range

  | If (e, e1, e2) ->
      begin
        match infer ctx e with
        | Bool ->
            let t1 = infer ctx e1 in
            let t2 = infer ctx e2 in
            if t1 = t2 then t1
            else type_mismatch t1 t2
        | t -> type_mismatch Bool t
      end

  | Let (x, e1, e2) ->
      let t1 = infer ctx e1 in
      infer (extend ctx (x, t1)) e2

  | Rec (f, t, e) ->
      let t' = infer ctx (Fn ([t], e in e with f = f)) in
      let t_sub = UTVarMap.singleton f_name f_t in
      let t'' = unify t_sub t' in
      let e' = subst t'' f e in
      infer ctx (Fn ([t] @ [f_t], e'))

  | Fn (xs, e) ->
      let xs' = List.map infer ctx xs in
      let t = infer ctx e in
      let t_sub = List.fold_right (fun t' t_sub (u, v) a) xs' xs in
      List.fold_right (fun a t_sub -> (a, v)) xs' t_sub

  | Apply (e, es) ->
      let t' = infer ctx e in
      match t' with
      | UArrow (t1, t2) ->
          let t1's = List.map (infer ctx) es in
          begin
            match t1's with
            | [] -> raise (TypeError (Apply_non_arrow t'))
            | es ->
                let tSub = List.concat_map (fun t -> [(t, t')]) es in
                let tSub = UTVarMap.union_list tSub (UTVarMap.from_list es) in
                begin
                  match t2 with
                  | UTVar u as t2' ->
                      if isBound u t2' then raise (TypeError (Type_mismatch t' t'))
                      else
                        if occurs (UTVar u) tSub then raise UnifError (Circular_reference tSub)
                        else
                          let tSub' = unifyVar tSub u t2' in
                          UTVarMap.add u t2' tSub
                  | t2' ->
                      let tSub' = unifyT tSub t2' in
                      UTVarMap.add f_name t2' tSub
                end
          end
      | _ -> raise (TypeError (Type_mismatch (UArrow (t1, t2)) t'))

and inferVar (t_var: string) (t: utp) (type_sub: utp UTVarMap.t) : utp UTVarMap.t =
  let rec occurs : utp -> bool = function
    | UInt | UBool -> false
    | UArrow (t1, t2) -> occurs t1 || occurs t2
    | UCross ts -> List.exists occurs ts
    | UTVar b ->
        if t_var = b
        then true
        else
          match UTVarMap.find_opt b type_sub with
          | None -> false
          | Some t' -> occurs t'
  in
  if occurs t_var t
  then raise (UnifError (Circular_reference t))
  else
    match UTVarMap.find_opt t_var type_sub with
    | None -> UTVarMap.add t_var t type_sub
    | Some t' -> unify t t' type_sub

and unifyT (type_sub: utp UTVarMap.t) (t1: utp) (t2: utp) : utp UTVarMap.t =
  match t1, t2 with
  | UInt, UInt -> type_sub
  | UBool, UBool -> type_sub
  | UTVar a, UTVar b when a = b -> type_sub
  | UArrow (t1, t1'), UArrow (t2, t2') ->
      let type_sub =
        unifyT type_sub t1 t2
        |> unifyT type_sub t1' t2'
      in
      let type_sub' = UTVarMap.add a t1' type_sub in
      let type_sub'' = UTVarMap.add b t2' type_sub' in
      type_sub''
  | UCross ts1, UCross ts2 ->
      let type_sub =
        List.fold_left2
          (fun type_sub (t1, t2) -> unifyT type_sub t1 t2)
          type_sub
          ts1
          ts2
      in
      type_sub
  | UTVar a, _ -> inferVar a t2 type_sub
  | _, UTVar a -> inferVar a t1 type_sub
  | _, _ -> unif_error @@ UnifMismatch (t1, t2)
```
Note that this code assumes that you have implemented the missing functions and modules in the prelude, as mentioned in the assignment.