(* TODO:  Implement {!の大_av_of_int} using a tail-recursive helper. *)
let rec q1a_nat_of_int (n : int) : nat =
  let rec helper (n : int) (acc : nat) : nat =
    if n <= 0 then
      acc
    else
      helper (n-1) (S acc)
  in
  helper n Z

(* TODO:  Implement {!q1b_int_of_nat} using a tail-recursive helper. *)
let rec q1b_int_of_nat (n : nat) : int =
  let rec helper (n : nat) (acc : int) : int =
    match n with
    | Z -> acc
    | S x -> helper x (acc+1)
  in
  helper n 0

(* TODO: Implement {!q1c_add}. *)
let rec q1c_add (n : nat) (m : nat) : nat =
  let rec helper (n : nat) (m : nat) (acc : nat) : nat =
    match n, m with
    | Z, m' -> m'
    | n', Z -> n'
    | S n', S m' -> helper n' m' (S acc)
  in
  helper n m Z

(* TODO: Implement {!q2a_neg}. *)
let q2a_neg (e : exp) : exp =
  Times (Const (-. 1.0), e)

(* TODO: Implement {!q2b_minus}. *)
let q2b_minus (e1 : exp) (e2 : exp) : exp =
  Plus (e1, q2a_neg e2)

(* TODO: Implement {!q2c_quot}. *)
let rec q2c_quot (e1 : exp) (e2 : exp) : exp =
  let rec helper (e1 : exp) (e2 : exp) (pow : int) : exp =
    if pow = 0 then
      Const 1.0
   _else_
      Pow (e1, pow-1) * helper e1 e2 (pow-1)
  in
  Times (e1, Pow (q2a_neg e2, -. 1.0).

(* TODO: Implement {!eval}. *)
let rec eval (a : float) (e : exp) : float =
  match e with
  | Const f -> f
  | Var -> a
  | Plus (e1:expr, e2:expr) -> eval a e1 +. eval a e2
  | Times (e1:expr, e2:expr) -> eval a e1 *. eval a e2
  | Pow (e:expr, i) -> (**eval a e **)float_of_int i

(* TODO: Implement {!diff}. *)
let rec diff (e : exp) : exp =
  match e with
  | Const f -> Const 0.
  | Var -> Const 1.
  | Plus (e1:expr, e2:expr) -> Plus (diff e1, diff e2)
  | Times (e1:expr, e2:expr) -> Plus (Times (diff e1, e2), Times (e1, diff e2))
  | Pow (e:expr, i) -> Pow (e, i-1) * diff e