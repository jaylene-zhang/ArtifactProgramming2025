type nat = Z | S of nat

(* Q1a: Convert an OCaml integer to a unary number (nat) using tail recursion. *)
let q1a_nat_of_int (n : int) : nat =
  (* TODO: Implement the function. *)
  let rec aux n acc =
    if n <= 0 then acc else aux (n - 1) (S acc)
  in
  aux n Z

(* Q1b: Convert a unary number (nat) to an OCaml integer using tail recursion. *)
let q1b_int_of_nat (n : nat) : int =
  (* TODO: Implement the function. *)
  let rec aux acc n =
    match n with
    | Z     -> acc
    | S t   -> aux (acc + 1) t
  in
  aux 0 n

(* Q1c: Add two unary numbers recursively without calling any other functions. *)
let rec q1c_add (n : nat) (m : nat) : nat =
  (* TODO: Implement the function. *)
  match n with
  | Z   -> m
  | S t -> S (q1c_add t m)

type exp =
  | Const of float
  | Var
  | Plus of exp * exp
  | Times of exp * exp
  | Pow of exp * int

(* Q2a: Negate an expression by multiplying it by -1.0. *)
let q2a_neg (e : exp) : exp =
  (* TODO: Implement the function. *)
  Times (Const (-1.0), e)

(* Q2b: Subtract the second expression from the first using Plus and q2a_neg. *)
let q2b_minus (e1 : exp) (e2 : exp) : exp =
  (* TODO: Implement the function. *)
  Plus (e1, q2a_neg e2)

(* Q2c: Represent the division of e1 by e2 using Times and Pow. *)
let q2c_quot (e1 : exp) (e2 : exp) : exp =
  (* TODO: Implement the function. *)
  Times (e1, Pow (e2, -1))

(* Q3: Evaluate an expression given a float value for the variable. *)
let rec eval (a : float) (e : exp) : float =
  (* TODO: Implement the function. *)
  match e with
  | Const c      -> c
  | Var          -> a
  | Plus (e1,e2) -> eval a e1 +. eval a e2
  | Times(e1,e2) -> eval a e1 *. eval a e2
  | Pow(e1,n)    -> (eval a e1) ** (float_of_int n)

(* Q4: Compute the derivative of an expression symbolically. *)
let rec diff (e : exp) : exp =
  (* TODO: Implement the function. *)
  match e with
  | Const _ -> Const 0.0
  | Var -> Const 1.0
  | Plus (e1, e2) -> Plus (diff e1, diff e2)
  | Times (e1, e2) -> Plus (Times (diff e1, e2), Times (e1, diff e2))
  | Pow (base, n) ->
      if n = 0 then Const 0.0
      else Times (Times (Const (float_of_int n), Pow (base, n - 1)), diff base)