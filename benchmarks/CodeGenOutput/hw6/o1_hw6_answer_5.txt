let rec traverse (f : 'a -> 'b option) (l : 'a list) : 'b list option =
  match l with
  | [] -> Some []
  | x :: xs ->
    match f x with
    | None -> None
    | Some y ->
      match traverse f xs with
      | None -> None
      | Some ys -> Some (y :: ys)

module Maybe = struct
  type 'a t =
    | Just of 'a
    | Nothing

  let return x = Just x
  let nothing = Nothing

  let bind a h =
    match a with
    | Just x -> h x
    | Nothing -> Nothing

  let ( >>= ) = bind

  let pp _ppv _fmt _m = ()
  let to_string _value_to_string _m = ""
end

let ap (mx : 'a Maybe.t) (fm : ('a -> 'b) Maybe.t) : 'b Maybe.t =
  let open Maybe in
  match fm with
  | Just f ->
    (match mx with
     | Just x -> Just (f x)
     | Nothing -> Nothing)
  | Nothing -> Nothing

let seq2 (m1 : 'a1 Maybe.t) (m2 : 'a2 Maybe.t) : ('a1 * 'a2) Maybe.t =
  let open Maybe in
  match m1, m2 with
  | Just x, Just y -> Just (x, y)
  | _ -> Nothing

let seq_predicate2
    (p1 : 'a1 -> 'b1 Maybe.t)
    (p2 : 'a2 -> 'b2 Maybe.t) : ('a1 * 'a2) -> ('b1 * 'b2) Maybe.t =
  fun (x1, x2) ->
    let open Maybe in
    bind (p1 x1) (fun y1 ->
      bind (p2 x2) (fun y2 ->
        return (y1, y2)
      )
    )

let map (f : 'a -> 'b) (a : 'a Maybe.t) : 'b Maybe.t =
  let open Maybe in
  match a with
  | Just x -> Just (f x)
  | Nothing -> Nothing

let rec traverse' (f : 'a -> 'b Maybe.t) (l : 'a list) : 'b list Maybe.t =
  let open Maybe in
  match l with
  | [] -> return []
  | x :: xs ->
    bind (f x) (fun y ->
      bind (traverse' f xs) (fun ys ->
        return (y :: ys)
      )
    )

type nat = Z | S of nat
type 'a church = 'a -> ('a -> 'a) -> 'a

type ('a, 'r) coption = ('a -> 'r) -> (unit -> 'r) -> 'r

type ('a, 'r) clist =
  | CList of (('a -> ('a, 'r) clist -> 'r) -> (unit -> 'r) -> 'r)

let church_to_nat (c : 'a church) : nat =
  c Z (fun n -> S n)

let rec nat_to_church (n : nat) : 'a church =
  match n with
  | Z -> (fun z _s -> z)
  | S n' ->
    let c' = nat_to_church n' in
    fun z s -> s (c' z s)

let coption_to_option (copt : ('a, 'r) coption) : 'a option =
  copt (fun x -> Some x) (fun () -> None)

let option_to_coption (m : 'a option) : ('a, 'r) coption =
  match m with
  | None -> (fun _some none -> none ())
  | Some x -> (fun some _none -> some x)

let rec clist_to_list ((CList clist) : ('a, 'r) clist) : 'a list =
  clist
    (fun x xs -> x :: clist_to_list xs)
    (fun () -> [])

let rec list_to_clist (l : 'a list) : ('a, 'r) clist =
  match l with
  | [] -> CList (fun _cons nil -> nil ())
  | x :: xs -> CList (fun cons nil -> cons x (list_to_clist xs))

let rec map_clist (f : 'a -> 'b) (clist : ('a, 'r) clist) : ('b, 'r) clist =
  match clist with
  | CList c ->
    CList (fun cons nil ->
      c (fun x xs -> cons (f x) (map_clist f xs))
        (fun () -> nil ())
    )