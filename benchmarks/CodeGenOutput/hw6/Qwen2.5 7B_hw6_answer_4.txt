(* Q1: 5 points *)
let rec traverse (f : 'a -> 'b option) (l : 'a list) : 'b list option =
  match l with
  | [] -> Some []
  | x :: xs ->
    (match f x with
     | Some y ->
       traverse f xs
       |> Option.map (fun ys -> y :: ys)
     | None -> None)

(* Q2.1: 2 points *)
let ap (mx : 'a Maybe.t) (fm : ('a -> 'b) Maybe.t) : 'b Maybe.t =
  match mx, fm with
  | Just x, Just f -> Just (f x)
  | _, _ -> Nothing

(* Q2.2: 2 points *)
let seq2 (m1 : 'a Maybe.t) (m2 : 'b Maybe.t) : ('a * 'b) Maybe.t =
  match m1, m2 with
  | Just x, Just y -> Just (x, y)
  | _, _ -> Nothing

(* Q2.3: 3 points *)
let seq_predicate2
    (p1 : 'a1 -> 'a2 Maybe.t)
    (p2 : 'a2 -> 'b2 Maybe.t) : ('a1 * 'b1) -> ('a2 * 'b2) Maybe.t =
  fun (a1, a2) ->
    match p1 a1 with
    | Just a2' -> match p2 a2' with Just b2' -> Just (a2', b2') | _ -> Nothing
    | _ -> Nothing

(* Q2.4: 3 points *)
let map (f : 'a -> 'b) (a : 'a Maybe.t) : 'b Maybe.t =
  match a with
  | Just x -> Just (f x)
  | Nothing -> Nothing

(* Q2.5: 10 points *)
let rec traverse' (f : 'a -> 'b Maybe.t) (l : 'a list) : 'b list Maybe.t =
  match l with
  | [] -> Just []
  | x :: xs ->
    (match f x with
     | Just y ->
       traverse' f xs
       |> Maybe.bind (fun ys -> Just (y :: ys))
     | Nothing -> Nothing)

(* Q3.1a: 2 points *)
let church_to_nat (c : 'a church) : nat =
  c (fun x -> S (x ())) Z

(* Q3.1b: 3 points *)
let rec nat_to_church (n : nat) : 'a church =
  match n with
  | Z -> fun x f -> x
  | S n' -> fun x f -> f (nat_to_church n' x f)

(* Q3.2a: 2 points *)
let coption_to_option (copt : ('a, 'r) coption) : 'a option =
  copt (fun x -> Some x) (fun () -> None)

(* Q3.2b: 3 points *)
let option_to_coption (m : 'a option) : ('a, 'r) coption =
  match m with
  | Some x -> fun k -> k x
  | None -> fun _ -> fun () -> ()

(* Q3.3a: 2 points *)
let rec clist_to_list ((CList clist) : ('a, 'r) clist) : 'a list =
  clist (fun x xs -> x :: xs) []

(* Q3.3b: 3 points *)
let rec list_to_clist (l : 'a list) : ('a, 'r) clist =
  match l with
  | [] -> CList (fun _ k -> k ())
  | x :: xs -> CList (fun k -> CList (fun x' xs' -> k (x, list_to_clist xs')))

(* Q4: 5 points *)
let rec map_clist (f : 'a -> 'b) (clist : ('a, 'r) clist) : ('b, 'r) clist =
  match clist with
  | CList f' -> CList (fun k u -> CList (fun x xs -> k (f x, xs) u) f')