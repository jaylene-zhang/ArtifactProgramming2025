(* Q1: Traverse (5 points) *)
let rec traverse (f : 'a -> 'b option) (l : 'a list) : 'b list option =
  (* TODO: Implement the function. *)
  match l with
  | [] -> Some []
  | x :: xs ->
      (match f x, traverse f xs with
       | Some y, Some ys -> Some (y :: ys)
       | _ -> None)

(* Q2.1: Calling Functions under Maybe.t (2 points) *)
let ap (mx : 'a Maybe.t) (fm : ('a -> 'b) Maybe.t) : 'b Maybe.t =
  let open Maybe in
  (* TODO: Implement the function. *)
  fm >>= (fun f -> mx >>= (fun x -> return (f x)))

(* Q2.2: Tuple under Maybe.t (2 points) *)
let seq2 (m1 : 'a1 Maybe.t) (m2 : 'a2 Maybe.t) : ('a1 * 'a2) Maybe.t =
  let open Maybe in
  (* TODO: Implement the function. *)
  m1 >>= (fun a -> m2 >>= (fun b -> return (a, b)))

(* Q2.3: Generalize 2.2 (3 points) *)
let seq_predicate2
    (p1 : 'a1 -> 'b1 Maybe.t)
    (p2 : 'a2 -> 'b2 Maybe.t) : ('a1 * 'a2) -> ('b1 * 'b2) Maybe.t =
  fun (x, y) ->
    let open Maybe in
    (* TODO: Implement the function. *)
    p1 x >>= (fun res1 ->
    p2 y >>= (fun res2 ->
    return (res1, res2)))

(* Q2.4: Map for Maybe.t (3 points) *)
let map (f : 'a -> 'b) (a : 'a Maybe.t) : 'b Maybe.t =
  let open Maybe in
  (* TODO: Implement the function. *)
  a >>= (fun x -> return (f x))

(* Q2.5: traverse' for Maybe.t (10 points) *)
let rec traverse' (f : 'a -> 'b Maybe.t) (l : 'a list) : 'b list Maybe.t =
  let open Maybe in
  (* TODO: Implement the function. *)
  match l with
  | [] -> return []
  | x :: xs ->
      f x >>= (fun y ->
      traverse' f xs >>= (fun ys ->
      return (y :: ys)))

(* Q3: Conversions *)

type nat = Z | S of nat
type 'a church = 'a -> ('a -> 'a) -> 'a

type ('a, 'r) coption = ('a -> 'r) -> (unit -> 'r) -> 'r

type ('a, 'r) clist =
  | CList of (('a -> ('a, 'r) clist -> 'r) -> (unit -> 'r) -> 'r)

(* Q3.1a: Church numeral to nat (2 points) *)
let church_to_nat (c : 'a church) : nat =
  (* TODO: Implement the function. *)
  c Z (fun n -> S n)

(* Q3.1b: Nat to Church numeral (3 points) *)
let rec nat_to_church (n : nat) : 'a church =
  (* TODO: Implement the function. *)
  fun x f ->
    match n with
    | Z -> x
    | S n' -> f (nat_to_church n' x f)

(* Q3.2a: coption to option (2 points) *)
let coption_to_option (copt : ('a, 'r) coption) : 'a option =
  (* TODO: Implement the function. *)
  copt (fun a -> Some a) (fun () -> None)

(* Q3.2b: option to coption (3 points) *)
let option_to_coption (m : 'a option) : ('a, 'r) coption =
  (* TODO: Implement the function. *)
  fun just nothing ->
    match m with
    | Some a -> just a
    | None -> nothing ()

(* Q3.3a: clist to list (2 points) *)
let rec clist_to_list ((CList clist) : ('a, 'r) clist) : 'a list =
  (* TODO: Implement the function. *)
  clist (fun a tail -> a :: clist_to_list tail) (fun () -> [])

(* Q3.3b: list to clist (3 points) *)
let rec list_to_clist (l : 'a list) : ('a, 'r) clist =
  (* TODO: Implement the function. *)
  match l with
  | [] -> CList (fun _cons nil -> nil ())
  | x :: xs -> CList (fun cons nil -> cons x (list_to_clist xs))

(* Q4: Map for clist (5 points) *)
let rec map_clist (f : 'a -> 'b) (clist : ('a, 'r) clist) : ('b, 'r) clist =
  (* TODO: Implement the function. *)
  match clist with
  | CList cl ->
      CList (fun cons nil ->
        cl (fun a tail -> cons (f a) (map_clist f tail)) nil)