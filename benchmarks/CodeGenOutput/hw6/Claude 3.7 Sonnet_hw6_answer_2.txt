(* Q1: 5 points *)
let rec traverse (f : 'a -> 'b option) (l : 'a list) : 'b list option =
  match l with
  | [] -> Some []
  | x :: xs ->
    match f x with
    | None -> None
    | Some y ->
      match traverse f xs with
      | None -> None
      | Some ys -> Some (y :: ys)

(* Q2.1: 2 points *)
let ap (mx : ('a -> 'b) Maybe.t) (my : 'a Maybe.t) : 'b Maybe.t =
  let open Maybe in
  mx >>= fun f ->
  my >>= fun y ->
  return (f y)

(* Q2.2: 2 points *)
let seq2 (m1 : 'a1 Maybe.t) (m2 : 'a2 Maybe.t) : ('a1 * 'a2) Maybe.t =
  let open Maybe in
  m1 >>= fun v1 ->
  m2 >>= fun v2 ->
  return (v1, v2)

(* Q2.3: 3 points *)
let seq_predicate2
    (p1 : 'a1 -> 'b1 Maybe.t)
    (p2 : 'a2 -> 'b2 Maybe.t) : ('a1 * 'a2) -> ('b1 * 'b2) Maybe.t =
  fun (a1, a2) ->
    let open Maybe in
    p1 a1 >>= fun b1 ->
    p2 a2 >>= fun b2 ->
    return (b1, b2)

(* Q2.4: 3 points *)
let map (f : 'a -> 'b) (a : 'a Maybe.t) : 'b Maybe.t =
  let open Maybe in
  a >>= fun x -> return (f x)

(* Q2.5: 10 points *)
let rec traverse' (f : 'a -> 'b Maybe.t) (l : 'a list) : 'b list Maybe.t =
  let open Maybe in
  match l with
  | [] -> return []
  | x :: xs ->
    f x >>= fun y ->
    traverse' f xs >>= fun ys ->
    return (y :: ys)

(* Q3.1a: 2 points *)
let church_to_nat (c : nat church) : nat =
  c Z (fun n -> S n)

(* Q3.1b: 3 points *)
let rec nat_to_church (n : nat) : 'a church =
  match n with
  | Z -> fun z s -> z
  | S n' -> fun z s -> s (nat_to_church n' z s)

(* Q3.2a: 2 points *)
let coption_to_option (copt : ('a, 'r) coption) : 'a option =
  copt (fun x -> Some x) (fun () -> None)

(* Q3.2b: 3 points *)
let option_to_coption (m : 'a option) : ('a, 'r) coption =
  fun k1 k2 ->
    match m with
    | Some x -> k1 x
    | None -> k2 ()

(* Q3.3a: 2 points*)
let rec clist_to_list ((CList clist) : ('a, 'r) clist) : 'a list =
  clist (fun x xs -> x :: clist_to_list xs) (fun () -> [])

(* Q3.3b: 3 points *)
let rec list_to_clist (l : 'a list) : ('a, 'r) clist =
  CList (fun cons nil ->
    match l with
    | [] -> nil ()
    | x :: xs -> cons x (list_to_clist xs)
  )

(* Q4: 5 points *)
let rec map_clist (f : 'a -> 'b) (clist : ('a, 'r) clist) : ('b, 'r) clist =
  match clist with
  | CList cl ->
    CList (fun cons nil ->
      cl (fun x xs -> 
          cons (f x) (map_clist f xs)
        ) 
        nil
    )