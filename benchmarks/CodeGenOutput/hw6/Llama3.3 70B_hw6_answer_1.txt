```ocaml
(* Q1 *)
let rec traverse (f : 'a -> 'b option) (l : 'a list) : 'b list option =
  match l with
  | [] -> Some []
  | h :: t -> match f h with
    | Some bh -> (match traverse f t with Some bt -> Some (bh :: bt) | None -> None)
    | None -> None

(* Q2.1 *)
let ap (mx : 'a Maybe.t) (fm : ('a -> 'b) Maybe.t) : 'b Maybe.t =
  let open Maybe in
  bind fm (fun f ->
    bind mx (fun m -> return (f m)))

(* Q2.2 *)
let seq2 (m1 : 'a1 Maybe.t) (m2 : 'a2 Maybe.t) : ('a1 * 'a2) Maybe.t =
  let open Maybe in
  bind m1 (fun a1 -> bind m2 (fun a2 -> return (a1, a2)))

(* Q2.3 *)
let seq_predicate2
    (p1 : 'a1 -> 'b1 Maybe.t)
    (p2 : 'b2 -> 'c2 Maybe.t) : ('a1 * 'b2) -> ('b1 * 'c2) Maybe.t =
  fun (a1, b2) ->
  let open Maybe in
  bind (p1 a1) (fun b1 -> p2 b2 >>= fun c2 -> return (b1, c2))

(* Q2.4 *)
let map (f : 'a -> 'b) (a : 'a Maybe.t) : 'b Maybe.t =
  let open Maybe in
  bind a (fun aa -> return (f aa))

(* Q2.5 *)
let rec traverse' (f : 'a -> 'b Maybe.t) (l : 'a list) : 'b list Maybe.t =
  let open Maybe in
  match l with
  | [] -> return []
  | h :: t -> bind (f h) (fun bh ->
      bind (traverse' f t) (fun bt -> return (bh :: bt)))

(* Q3.1a *)
let church_to_nat (c : 'a church) : nat =
  c (fun x -> S x) Z

(* Q3.1b *)
let rec nat_to_church (n : nat) : 'a church =
  match n with
  | Z -> fun _ z -> z
  | S n' -> fun f -> fun x -> f (nat_to_church n' f x)

(* Q3.2a *)
let coption_to_option (copt : ('a, 'r) coption) : 'a option =
  copt (fun a -> Some a) (fun () -> None)

(* Q3.2b *)
let option_to_coption (m : 'a option) : ('a, 'r) coption =
  match m with
  | Some a -> fun k _ -> k a
  | None -> fun _ k -> k ()

(* Q3.3a *)
let rec clist_to_list ((CList clist) : ('a, 'r) clist) : 'a list =
  clist (fun h t -> h :: clist_to_list (t ())) (fun () -> [])

(* Q3.3b *)
let rec list_to_clist (l : 'a list) : ('a, 'r) clist =
  match l with
  | [] -> CList (fun k _ -> k ())
  | h :: t ->
      CList (fun k-return k-nil ->
        k-return h (list_to_clist t k-return k-nil))

(* Q4 *)
let rec map_clist (f : 'a -> 'b) (clist : ('a, 'r) clist) : ('b, 'r) clist =
  match clist with
  | CList clist ->
      CList (fun k-return k-nil ->
        clist (fun h t ->
          k-return (f h) (map_clist f (t k-return k-nil)))
          k-nil)
```