```ocaml
(* TODO: Implement the function. *)

(* Q1: 5 points *)
let rec traverse (f : 'a -> 'b option) (l : 'a list) : 'b list option =
  match l with
  | [] -> Some []
  | x :: xs ->
      match f x with
      | None -> None
      | Some y -> (
          match traverse f xs with
          | None -> None
          | Some ys -> Some (y :: ys))

(* TODO: Implement the functions Q2.1 *)
(* Q2.1: 2 points *)
let ap (fm : ('a -> 'b) Maybe.t) (mx : 'a Maybe.t) : 'b Maybe.t =
  let open Maybe in
  match fm with
  | Just f -> (
      match mx with
      | Just x -> Just (f x)
      | Nothing -> Nothing)
  | Nothing -> Nothing

(* TODO: Implement the functions Q2.2 *)
(* Q2.2: 2 points *)
let seq2 (m1 : 'a1 Maybe.t) (m2 : 'a2 Maybe.t) : ('a1 * 'a2) Maybe.t =
  let open Maybe in
  match m1 with
  | Just x -> (
      match m2 with
      | Just y -> Just (x, y)
      | Nothing -> Nothing)
  | Nothing -> Nothing

(* TODO: Implement the functions Q2.3 *)
(* Q2.3: 3 points *)
let seq_predicate2
    (p1 : 'a1 -> 'b1 Maybe.t)
    (p2 : 'a2 -> 'b2 Maybe.t) : ('a1 * 'a2) -> ('b1 * 'b2) Maybe.t =
 fun (a1, a2) ->
  let open Maybe in
  match p1 a1 with
  | Just b1 -> (
      match p2 a2 with
      | Just b2 -> Just (b1, b2)
      | Nothing -> Nothing)
  | Nothing -> Nothing

(* TODO: Implement the functions Q2.4 *)
(* Q2.4: 3 points *)
let map (f : 'a -> 'b) (a : 'a Maybe.t) : 'b Maybe.t =
  let open Maybe in
  match a with
  | Just x -> Just (f x)
  | Nothing -> Nothing

(* TODO: Implement the functions Q2.5 *)
(* Q2.5: 10 points *)
let rec traverse' (f : 'a -> 'b Maybe.t) (l : 'a list) : 'b list Maybe.t =
  let open Maybe in
  match l with
  | [] -> return []
  | x :: xs -> (
      match f x with
      | Nothing -> nothing
      | Just y -> (
          match traverse' f xs with
          | Nothing -> nothing
          | Just ys -> return (y :: ys)))

(* Given *)

(* Q3 *)

type nat = Z | S of nat
type 'a church = 'a -> ('a -> 'a) -> 'a

(* type 'a option = Some of 'a | None *)
type ('a, 'r) coption = ('a -> 'r) -> (unit -> 'r) -> 'r

(* type 'a list = (::) of 'a * 'a list | [] *)
type ('a, 'r) clist =
  | CList of (('a -> ('a, 'r) clist -> 'r) -> (unit -> 'r) -> 'r)
  (* OCaml does not support circular types. The circularity is guarded by
     the constructor [CList]. *)

(* TODO: Implement the function Q3.1a *)

(* Q3.1a: 2 points *)
let church_to_nat (c : 'a church) : nat =
  c Z (fun x -> S x)

(* TODO: Implement the function Q3.1b *)

(* Q3.1b: 3 points *)
let rec nat_to_church (n : nat) : 'a church =
  match n with
  | Z -> fun x _ -> x
  | S n' ->
      let c' = nat_to_church n' in
      fun x f -> f (c' x f)

(* TODO: Implement the function Q3.2a *)

(* Q3.2a: 2 points *)
let coption_to_option (copt : ('a, 'r) coption) : 'a option =
  copt (fun a -> Some a) (fun () -> None)

(* TODO: Implement the function Q3.2b *)

(* Q3.2b: 3 points *)
let option_to_coption (m : 'a option) : ('a, 'r) coption =
 fun succ fail ->
  match m with Some a -> succ a | None -> fail ()

(* TODO: Implement the function Q3.3a *)

(* Q3.3a: 2 points*)
let rec clist_to_list ((CList clist) : ('a, 'r) clist) : 'a list =
  clist
    (fun h t -> h :: clist_to_list t)
    (fun () -> [])

(* TODO: Implement the function Q3.3b *)

(* Q3.3b: 3 points *)
let rec list_to_clist (l : 'a list) : ('a, 'r) clist =
  CList
    (fun cons nil ->
      match l with
      | [] -> nil ()
      | h :: t -> cons h (list_to_clist t))

(* Q4: 5 points *)
let rec map_clist (f : 'a -> 'b) (clist : ('a, 'r) clist) : ('b, 'r) clist =
  CList
    (fun cons nil ->
      let (CList clist') = clist in
      clist'
        (fun h t -> cons (f h) (map_clist f t))
        (fun () -> nil ()))
```