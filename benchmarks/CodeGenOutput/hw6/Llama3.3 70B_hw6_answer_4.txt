```ocaml
(* Q1: 5 points *)
let rec traverse (f : 'a -> 'b option) (l : 'a list) : 'b list option =
  match l with
  | [] -> Some []
  | h :: t -> 
    match f h with
    | Some fh -> 
      (match traverse f t with
       | Some ft -> Some (fh :: ft)
       | None -> None)
    | None -> None


(* Q2.1: 2 points *)
let ap (mx : 'a Maybe.t) (fm : ('a -> 'b) Maybe.t) : 'b Maybe.t =
  let open Maybe in
  mx >>= fun x -> fm >>= fun f -> return (f x)


(* Q2.2: 2 points *)
let seq2 (m1 : 'a1 Maybe.t) (m2 : 'a2 Maybe.t) : ('a1 * 'a2) Maybe.t =
  let open Maybe in
  m1 >>= fun a1 -> m2 >>= fun a2 -> return (a1, a2)


(* Q2.3: 3 points *)
let seq_predicate2 
    (p1 : 'a1 -> 'b1 Maybe.t)
    (p2 : 'b2 -> 'c2 Maybe.t) 
    : ('a1 * 'b2) -> ('b1 * 'c2) Maybe.t =
  fun (a, b) -> 
  let open Maybe in
  p1 a >>= fun b1 -> p2 b >>= fun c2 -> return (b1, c2)


(* Q2.4: 3 points *)
let map (f : 'a -> 'b) (a : 'a Maybe.t) : 'b Maybe.t =
  let open Maybe in
  a >>= fun a -> return (f a)


(* Q2.5: 10 points *)
let rec traverse' (f : 'a -> 'b Maybe.t) (l : 'a list) : 'b list Maybe.t =
  let open Maybe in
  match l with
  | [] -> return []
  | h :: t -> 
    f h >>= fun fh -> traverse' f t >>= fun ft -> return (fh :: ft)


(* Q3.1a: 2 points *)
let church_to_nat (c : 'a church) : nat =
  c Z (fun x -> S x)


(* Q3.1b: 3 points *)
let rec nat_to_church (n : nat) : 'a church =
  match n with
  | Z -> fun x _ -> x
  | S n -> fun x f -> f (nat_to_church n x f)


(* Q3.2a: 2 points *)
let coption_to_option (copt : ('a, 'r) coption) : 'a option =
  copt (fun x -> Some x) (fun () -> None)


(* Q3.2b: 3 points *)
let option_to_coption (m : 'a option) : ('a, 'r) coption =
  match m with
  | Some x -> fun f _ -> f x
  | None -> fun _ g -> g ()


(* Q3.3a: 2 points *)
let rec clist_to_list ((CList clist) : ('a, 'r) clist) : 'a list =
  clist (fun h t -> h :: clist_to_list t) (fun () -> [])


(* Q3.3b: 3 points *)
let rec list_to_clist (l : 'a list) : ('a, 'r) clist =
  match l with
  | [] -> CList (fun _ g -> g ())
  | h :: t -> CList (fun f g -> f h (list_to_clist t))


(* Q4: 5 points *)
let rec map_clist (f : 'a -> 'b) (clist : ('a, 'r) clist) : ('b, 'r) clist =
  match clist with
  | CList clist -> 
    CList (fun g h -> 
            clist (fun x tl -> g (f x) (map_clist f tl)) h)
```