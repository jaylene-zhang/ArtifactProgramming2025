(* Q1: 5 points *)
let rec traverse (f : 'a -> 'b option) (l : 'a list) : 'b list option =
  match l with
  | [] -> Some []
  | x :: xs ->
      (match f x with
       | None -> None
       | Some y -> traverse f xs |> Option.map (fun ys -> y :: ys))

(* Q2.1: 2 points *)
let ap (mx : 'a Maybe.t) (fm : ('a -> 'b) Maybe.t) : 'b Maybe.t =
  Maybe.bind mx (function
    | Nothing -> Maybe.nothing
    | Just f -> Maybe.bind fm (Just f))

(* Q2.2: 2 points *)
let seq2 (m1 : 'a Maybe.t) (m2 : 'b Maybe.t) : ('a * 'b) Maybe.t =
  Maybe.bind m1 (function
    | Nothing -> Maybe.nothing
    | Just a -> Maybe.bind m2 (Just (a,)))

(* Q2.3: 3 points *)
let seq_predicate2
    (p1 : 'a1 -> 'a2 Maybe.t)
    (p2 : 'a2 -> 'b2 Maybe.t)
    ((a1, a2) : 'a1 * 'a2) : ('b1 * 'b2) Maybe.t =
  Maybe.bind (p1 a1) (function
    | Nothing -> Maybe.nothing
    | Just b1 -> p2 a2 >>= Just (b1,))

(* Q2.4: 3 points *)
let map (f : 'a -> 'b) (a : 'a Maybe.t) : 'b Maybe.t =
  Maybe.bind a (Just << f)

(* Q2.5: 10 points *)
let rec traverse' (f : 'a -> 'b Maybe.t) (l : 'a list) : 'b list Maybe.t =
  match l with
  | [] -> Maybe.return []
  | x :: xs ->
      f x >>= fun y ->
      traverse' f xs >>= fun ys ->
      Maybe.return (y :: ys)

(* Q3 *)

(* Q3.1a: 2 points *)
let church_to_nat (c : 'a church) : nat =
  c (fun x acc -> S (acc x)) Z

(* Q3.1b: 3 points *)
let rec nat_to_church (n : nat) : 'a church =
  match n with
  | Z -> ( fun k z -> z )
  | S m -> ( fun k z -> k (nat_to_church m) )

(* Q3.2a: 2 points *)
let coption_to_option (copt : ('a, 'r) coption) : 'a option =
  copt (Some) (fun () -> None)

(* Q3.2b: 3 points *)
let option_to_coption (m : 'a option) : ('a, 'r) coption =
  m (fun a k -> k ()) (fun () -> None)

(* Q3.3a: 2 points *)
let rec clist_to_list ((CList clist) : ('a, 'r) clist) : 'a list =
  clist (fun x xs -> x :: xs) []

(* Q3.3b: 3 points *)
let rec list_to_clist (l : 'a list) : ('a, 'r) clist =
  match l with
  | [] -> CList (fun _ -> fun () -> None)
  | x :: xs ->
      CList (fun k acc ->
        k x (fun () -> list_to_clist xs |> k))

(* Q4: 5 points *)
let rec map_clist (f : 'a -> 'b) (clist : ('a, 'r) clist) : ('b, 'r) clist =
  match clist with
  | CList clist ->
      CList (fun k acc ->
        clist (fun x xs ->
          k (f x) (fun () -> xs |> map_clist f |> k)))