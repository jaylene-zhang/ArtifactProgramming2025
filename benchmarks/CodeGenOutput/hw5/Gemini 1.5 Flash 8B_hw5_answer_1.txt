```OCaml
(* Question 1: Tree Depth *)


let rec tree_depth t = match t with
  | Empty -> 0
  | Tree (l, _, r) -> 1 + max (tree_depth l) (tree_depth r)

let rec tree_depth_cps t k =
  match t with
  | Empty -> k 0
  | Tree (l, _, r) ->
    tree_depth_cps l (fun d1 ->
      tree_depth_cps r (fun d2 -> k (1 + max d1 d2)))

(* Question 2 : Finding Subtrees *)

type 'a option = None | Some of 'a

let find_subtree_cps ls tree =
  let rec helper ls tree sc fc =
    match ls, tree with
    | [], _ -> sc (Some tree)
    | _, Empty -> fc ()
    | h :: tl, Tree (l, v, r) ->
      if h = v then
        helper tl tree sc fc
      else
        helper ls l sc (fun () -> helper ls r sc fc)
    | _, _ -> fc ()
  in
  helper ls tree (fun x -> x) (fun () -> None)



(* Question 3 : Parser *)
type expr = Const of int | Plus of expr * expr


(* ... (helper functions for parser_cps are omitted for brevity due to length) ...*)

(* Helper functions for parsing (Note:  
   replace the following with your properly implemented CPS parser helpers): *)
let rec parse_expr_cps tokens k err =
  match tokens with
  | [] -> err ()
  | hd :: tl ->
      (match hd with
       | Const_token (i) ->
          k (Const i) tl
       | Plus_token -> parse_expr_rhs_cps tl (fun e1 ->
                          fun tl2 ->
                             parse_expr_cps tl2 (fun e2->
                                      k (Plus(e1,e2))) err ) err []
       | _ -> err ())



let parse_expr_rhs_cps tokens k err l =
     parse_expr_cps tokens k err
   
let rec parser_cps tokens =
  let sc = Some
  and fc = None in
  parse_expr_cps tokens (fun e -> sc e) fc

  


```