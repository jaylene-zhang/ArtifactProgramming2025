```ocaml
(* Question 1: Tree Depth *)


let rec tree_depth t = match t with
  | Empty -> 0
  | Tree (l, _, r) -> 1 + max (tree_depth l) (tree_depth r)

(* TODO: Implement a CPS style tree_depth_cps function.*)
let tree_depth_cps t = 
  let rec depth_helper t k =
    match t with
    | Empty -> k 0
    | Tree (l, _, r) -> 
      depth_helper l (fun l_depth ->
        depth_helper r (fun r_depth ->
          k (1 + max l_depth r_depth)
        )
      )
  in
  depth_helper t (fun x -> x)

(* Question 2: Finding Subtrees *)


(* TODO: Implement a CPS style find_subtree_cont function.*)
let find_subtree_cps ls tree =
  let rec helper ls tree sc fc =
    match ls with
    | [] -> sc (Some tree)
    | hd :: tl ->
      match tree with
      | Empty -> fc ()
      | Tree (l, v, r) ->
        if v = hd then
          helper tl l (fun res -> sc res) (fun () -> 
            helper tl r (fun res -> sc res) (fun () -> fc ()))
        else fc ()
  in
  helper ls tree (fun x -> x) (fun () -> None)

(* Question 3: Arithmetic Experssion Parser *)

type token =
  | INT of int
  | PLUS
  | TIMES
  | LPAR
  | RPAR

type expr =
  | Const of int
  | Plus of expr * expr
  | Times of expr * expr

let eval e v =
  let rec helper e =
    match e with
    | Const i -> i
    | Plus (e1, e2) -> helper e1 + helper e2
    | Times (e1, e2) -> helper e1 * helper e2
  in
  helper e

type ('r, 'a) parser_LN = token list -> (unit -> 'r) -> (token list -> 'a -> 'r) -> 'r

(* TODO: Implement a CPS style parser function.*)
let parser_cps t =
  let rec parse_expr tokens sc fc =
    parse_term tokens (fun tokens' e ->
      match tokens' with
      | PLUS :: rest ->
        parse_expr rest (fun tokens'' e' ->
          sc tokens'' (Plus (e, e'))
        ) fc
      | _ -> sc tokens' e
    ) fc

  and parse_term tokens sc fc =
    parse_factor tokens (fun tokens' e ->
      match tokens' with
      | TIMES :: rest ->
        parse_term rest (fun tokens'' e' ->
          sc tokens'' (Times (e, e'))
        ) fc
      | _ -> sc tokens' e
    ) fc

  and parse_factor tokens sc fc =
    match tokens with
    | INT i :: rest -> sc rest (Const i)
    | LPAR :: rest ->
      parse_expr rest (fun tokens' e ->
        match tokens' with
        | RPAR :: rest' -> sc rest' e
        | _ -> fc ()
      ) fc
    | _ -> fc ()
  in

  let success e = Some e in
  let failure () = None in

  parse_expr t (fun _ e -> success e) (fun () -> failure ())

let check_parser t v = match parser_cps t with
  | None -> None
  | Some(e) -> Some(eval e v)
```