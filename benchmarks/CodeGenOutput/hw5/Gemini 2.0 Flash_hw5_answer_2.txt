```ocaml
(* Question 1: Tree Depth *)


let rec tree_depth t = match t with
  | Empty -> 0
  | Tree (l, _, r) -> 1 + max (tree_depth l) (tree_depth r)

(* TODO: Implement a CPS style tree_depth_cps function.*)
let tree_depth_cps t = 
  let rec depth_helper tree succ =
    match tree with
    | Empty -> succ 0
    | Tree (l, _, r) ->
      depth_helper l (fun l_depth ->
          depth_helper r (fun r_depth ->
              succ (1 + max l_depth r_depth)
            )
        )
  in
  depth_helper t (fun depth -> depth)

(* Question 2: Finding Subtrees *)


(* TODO: Implement a CPS style find_subtree_cont function.*)
let find_subtree_cps ls tree =
  let rec helper ls tree sc fc =
    match ls with
    | [] -> sc (Some tree)
    | hd :: tl ->
      match tree with
      | Empty -> fc ()
      | Tree (l, v, r) ->
        if v = hd then
          let succ_cont subtree = sc (Some subtree) in
          let fail_cont () = 
            let succ_right subtree = sc (Some subtree) in
            let fail_right () = fc () in
              helper ls r succ_right fail_right
          in
          helper tl l succ_cont fail_cont
            

        else
          let succ_cont_left subtree = sc (Some subtree) in
            let fail_cont_left () = 
                let succ_cont_right subtree = sc (Some subtree) in
                let fail_cont_right () = fc () in
                helper ls r succ_cont_right fail_cont_right 
            in
          helper ls l succ_cont_left fail_cont_left
            
  in
  helper ls tree (fun x -> x) (fun () -> None)

(* Question 3: Arithmetic Experssion Parser *)

type token =
  | Tok_Int of int
  | Tok_Plus
  | Tok_Mult
  | Tok_LParen
  | Tok_RParen

type expr =
  | Const of int
  | Plus of expr * expr
  | Mult of expr * expr

type env = (string * int) list

let eval e v =
  let rec eval' e v =
    match e with
    | Const i -> i
    | Plus (e1, e2) -> eval' e1 v + eval' e2 v
    | Mult (e1, e2) -> eval' e1 v * eval' e2 v
  in
  eval' e v

(* TODO: Implement a CPS style parser function.*)
type ('r, 'a) parser_LN = token list -> (unit -> 'r) -> (token list -> 'a -> 'r) -> 'r

let parser_cps t =
  let rec parse_expr tokens succ fail =
    parse_term tokens (fun tokens' expr' ->
      parse_rest tokens' expr' succ fail)
    fail
  and parse_rest tokens expr_acc succ fail =
    match tokens with
    | Tok_Plus :: rest ->
      parse_term rest (fun tokens' expr' ->
        parse_rest tokens' (Plus (expr_acc, expr')) succ fail)
      fail
    | _ -> succ tokens expr_acc
  and parse_term tokens succ fail =
    parse_factor tokens (fun tokens' factor' ->
        parse_term_rest tokens' factor' succ fail
    ) fail
  and parse_term_rest tokens expr_acc succ fail =
    match tokens with
    | Tok_Mult :: rest ->
      parse_factor rest (fun tokens' factor' ->
        parse_term_rest tokens' (Mult (expr_acc, factor')) succ fail
      ) fail
    | _ -> succ tokens expr_acc
  and parse_factor tokens succ fail =
    match tokens with
    | Tok_Int i :: rest -> succ rest (Const i)
    | Tok_LParen :: rest ->
      parse_expr rest (fun tokens' expr' ->
        match tokens' with
        | Tok_RParen :: rest' -> succ rest' expr'
        | _ -> fail ()
      ) fail
    | _ -> fail ()
  in
  match parse_expr t (fun tokens expr -> Some expr) (fun () -> None) with
  | Some e -> Some e
  | None -> None

let check_parser t v = match parser_cps t with
  | None -> None
  | Some(e) -> Some(eval e v)
```