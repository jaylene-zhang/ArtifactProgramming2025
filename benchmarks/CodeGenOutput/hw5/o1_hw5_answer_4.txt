type 'a tree = Empty | Tree of 'a tree * 'a * 'a tree;;

(* Question 1 *)
let tree_depth_cps t =
  let rec depth_helper t sc =
    match t with
    | Empty -> sc 0
    | Tree(l, _, r) ->
      depth_helper l (fun dl ->
      depth_helper r (fun dr ->
        sc (1 + max dl dr)))
  in
  depth_helper t (fun d -> d)

(* Question 2 *)
let find_subtree_cps ls tree =
  let rec helper ls tree sc fc =
    match ls, tree with
    | [], _ -> sc tree
    | _, Empty -> fc ()
    | x :: xs, Tree(l,v,r) ->
       if x = v then
         if xs = [] then sc (Tree(l,v,r))
         else
           helper xs l sc (fun () ->
           helper xs r sc fc)
       else
         fc ()
  in
  helper ls tree (fun t -> Some t) (fun () -> None)

(* Question 3 *)
type token = INT of int | PLUS | TIMES | LPAREN | RPAREN
type expr = Const of int | Plus of expr * expr | Times of expr * expr

type ('r, 'a) parser_LN = token list -> (unit -> 'r) -> (token list -> 'a -> 'r) -> 'r

let parser_cps t =
  let rec parseNumber toks fc sc =
    match toks with
    | INT i :: rest -> sc rest (Const i)
    | _ -> fc ()
  and parseFactor toks fc sc =
    match toks with
    | LPAREN :: rest ->
      parseExpr rest fc (fun rest' e ->
        match rest' with
        | RPAREN :: rest'' -> sc rest'' e
        | _ -> fc ())
    | _ -> parseNumber toks fc sc
  and parseTerm toks fc sc =
    parseFactor toks fc (fun rest f ->
      let rec loop rest acc =
        match rest with
        | TIMES :: rest' ->
          parseFactor rest' fc (fun rest'' f2 ->
            loop rest'' (Times (acc, f2)))
        | _ -> sc rest acc
      in
      loop rest f)
  and parseExpr toks fc sc =
    parseTerm toks fc (fun rest t ->
      let rec loop rest acc =
        match rest with
        | PLUS :: rest' ->
          parseTerm rest' fc (fun rest'' t2 ->
            loop rest'' (Plus (acc, t2)))
        | _ -> sc rest acc
      in
      loop rest t)
  in
  parseExpr t (fun () -> None) (fun rest e -> if rest = [] then Some e else None)