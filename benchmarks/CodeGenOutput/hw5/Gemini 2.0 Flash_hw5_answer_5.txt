```ocaml
(* Question 1: Tree Depth *)

let rec tree_depth t = match t with
  | Empty -> 0
  | Tree (l, _, r) -> 1 + max (tree_depth l) (tree_depth r)

(* TODO: Implement a CPS style tree_depth_cps function.*)
let tree_depth_cps t =
  let rec depth_helper t k =
    match t with
    | Empty -> k 0
    | Tree (l, _, r) ->
      depth_helper l (fun l_depth ->
          depth_helper r (fun r_depth ->
              k (1 + max l_depth r_depth)))
  in
  depth_helper t (fun x -> x)

(* Question 2: Finding Subtrees *)

(* TODO: Implement a CPS style find_subtree_cont function.*)
let find_subtree_cps ls tree =
  let rec helper ls tree sc fc =
    match ls, tree with
    | [], _ -> sc (Some tree)
    | _, Empty -> fc ()
    | h::tl, Tree(l,v,r) ->
      if h = v then
        helper tl tree sc fc
      else
        helper ls l (fun x -> match x with
            | Some _ -> sc x
            | None -> helper ls r sc fc
          ) fc
  in
  helper ls tree (fun x -> x) (fun () -> None)

(* Question 3: Arithmetic Experssion Parser *)

(* TODO: Implement a CPS style parser function.*)
type ('r, 'a) parser_LN = token list -> (unit -> 'r) -> (token list -> 'a -> 'r) -> 'r

type token = Num of int | Plus | Minus | Times | Div | LParen | RParen
type expr = Const of int | Plus of expr * expr | Minus of expr * expr | Times of expr * expr | Div of expr * expr

let eval e v =
  let rec eval_helper e =
    match e with
    | Const(i) -> i
    | Plus(e1, e2) -> eval_helper e1 + eval_helper e2
    | Minus(e1, e2) -> eval_helper e1 - eval_helper e2
    | Times(e1, e2) -> eval_helper e1 * eval_helper e2
    | Div(e1, e2) -> eval_helper e1 / eval_helper e2
  in
  eval_helper e

let parser_cps t =
  let rec expr tokens sc fc =
    term tokens (fun e tokens' ->
        expr_tail tokens' e sc fc
      ) fc
  and expr_tail tokens e_acc sc fc =
    match tokens with
    | Plus :: tl ->
      term tl (fun e tokens' ->
          expr_tail tokens' (Plus (e_acc, e)) sc fc
        ) fc
    | Minus :: tl ->
      term tl (fun e tokens' ->
          expr_tail tokens' (Minus (e_acc, e)) sc fc
        ) fc
    | _ -> sc e_acc tokens
  and term tokens sc fc =
    factor tokens (fun e tokens' ->
        term_tail tokens' e sc fc
      ) fc
  and term_tail tokens e_acc sc fc =
    match tokens with
    | Times :: tl ->
      factor tl (fun e tokens' ->
          term_tail tokens' (Times (e_acc, e)) sc fc
        ) fc
    | Div :: tl ->
      factor tl (fun e tokens' ->
          term_tail tokens' (Div (e_acc, e)) sc fc
        ) fc
    | _ -> sc e_acc tokens
  and factor tokens sc fc =
    match tokens with
    | Num i :: tl -> sc (Const i) tl
    | LParen :: tl ->
      expr tl (fun e tokens' ->
          match tokens' with
          | RParen :: tl' -> sc e tl'
          | _ -> fc ()
        ) fc
    | _ -> fc ()
  in
  match expr t (fun e tl -> Some e) (fun () -> None) with
  | Some e -> if List.length t > 0 then Some e else Some e
  | None -> None

let check_parser t v = match parser_cps t with
  | None -> None
  | Some(e) -> Some(eval e v)
```