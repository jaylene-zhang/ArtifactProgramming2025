```ocaml
(* Question 1: Tree Depth *)
let rec tree_depth t = match t with
  | Empty -> 0
  | Tree (l, _, r) -> 1 + max (tree_depth l) (tree_depth r)

let tree_depth_cps t = 
  let rec depth_helper t sc _ = 
    match t with 
    | Empty -> sc 0
    | Tree (l, _, r) -> 
      depth_helper l (fun h1 -> 
        depth_helper r (fun h2 -> 
          sc (1 + max h1 h2)) id)
  in 
  depth_helper t (fun n -> n) id


(* Question 2: Finding Subtrees *)
let find_subtree_cps ls tree =
  let rec helper ls tree sc fc =
    match ls with
    | [] -> sc (Some tree)
    | _ when tree = Empty -> fc tree
    | _ :: _ -> 
      match tree with 
      | Empty -> fc tree
      | Tree (l, x, r) -> 
        helper (List.tl ls) l (fun l' -> 
          if List.hd ls = x then sc (Some l') else fc l') (fun _ -> 
          helper (List.tl ls) r (fun r' -> 
            if List.hd ls = x then sc (Some r') else fc r') fc)
  in 
  helper ls tree (fun t -> Some t) (fun _ -> None)


(* Question 3: Arithmetic Expression Parser *)
type ('r, 'a) parser_LN = token list -> (unit -> 'r) -> (token list -> 'a -> 'r) -> 'r

type token =
  | Num of int
  | Plus
  | Minus
  | Mult
  | Div
  | LParen
  | RParen
  | EOF

type expr =
  | Const of int
  | Plus of expr * expr
  | Minus of expr * expr
  | Mult of expr * expr
  | Div of expr * expr

let eval e v =
  let rec eval_expr e =
    match e with
    | Const n -> n
    | Plus (e1, e2) -> eval_expr e1 + eval_expr e2
    | Minus (e1, e2) -> eval_expr e1 - eval_expr e2
    | Mult (e1, e2) -> eval_expr e1 * eval_expr e2
    | Div (e1, e2) -> eval_expr e1 / eval_expr e2
  in
  eval_expr e

let parser_factor sc fc tokens =
  match tokens with
  | Num n :: tl -> sc (Const n, tl)
  | LParen :: tl -> 
    parser_expr (fun (e, tl) -> 
      match tl with
      | RParen :: tl -> sc (e, tl)
      | _ -> fc tl) fc tl
  | _ -> fc tokens

let parser_term sc fc tokens =
  let rec helper tokens e =
    match tokens with
    | Mult :: tl -> 
      parser_factor (fun (e', tl) -> 
        helper tl (Mult (e, e'))) fc tl
    | Div :: tl -> 
      parser_factor (fun (e', tl) -> 
        helper tl (Div (e, e'))) fc tl
    | _ -> sc (e, tokens)
  in
  parser_factor (fun (e, tokens) -> 
    helper tokens e) fc tokens

let parser_expr sc fc tokens =
  let rec helper tokens e =
    match tokens with
    | Plus :: tl -> 
      parser_term (fun (e', tl) -> 
        helper tl (Plus (e, e'))) fc tl
    | Minus :: tl -> 
      parser_term (fun (e', tl) -> 
        helper tl (Minus (e, e'))) fc tl
    | _ -> sc (e, tokens)
  in
  parser_term (fun (e, tokens) -> 
    helper tokens e) fc tokens

let parser_cps tokens =
  parser_expr (fun (e, []) -> Some e) (fun _ -> None) tokens

let check_parser t v = match parser_cps t with
  | None -> None
  | Some(e) -> Some(eval e v)
```