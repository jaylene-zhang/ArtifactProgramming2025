```ocaml
(* Question 1: Tree Depth *)


let rec tree_depth t = match t with
  | Empty -> 0
  | Tree (l, _, r) -> 1 + max (tree_depth l) (tree_depth r)

let rec tree_depth_cps t k =
  match t with
  | Empty -> k 0
  | Tree (l, _, r) ->
    tree_depth_cps l (fun d1 ->
      tree_depth_cps r (fun d2 -> k (1 + max d1 d2)))


(* Question 2 : Finding Subtrees *)


type 'a option =
  | None
  | Some of 'a

let find_subtree_cps ls tree =
  let rec helper ls tree sc fc =
    match ls, tree with
    | [], _ -> sc tree
    | h::tl, Empty -> fc ()
    | h::tl, Tree (l, v, r) ->
      if h = v then
        helper tl tree sc fc
      else (
        helper tl l sc (fun() -> helper tl r sc fc)
      )
  in
  helper ls tree (fun x -> Some x) (fun () -> None)


(* Question 3 : Parser *)

(* Placeholder types and functions for Question 3. *)
type expr =
  | Const of int
  | Plus of expr * expr
  | Times of expr * expr



type token =
  | Int of int
  | Plus_op
  | Times_op
  | End_input

let rec eval e v =
  match e with
  | Const i -> i
  | Plus (e1, e2) -> eval e1 v + eval e2 v
  | Times (e1, e2) -> eval e1 v * eval e2 v




(*  Placeholder for parser_cps.
  Implementation of parser_cps will require significant code.
  The current placeholder returns Some(Const 42) for demonstration of the general form. *)
let parser_cps tokens =
  match tokens with
  | Int(42)::[] -> Some (Const 42)
  | _ -> None
;;
```