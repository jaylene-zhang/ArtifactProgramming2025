type 'a tree = Empty | Tree of 'a tree * 'a * 'a tree;;

(* Question 1: Tree Depth *)
let rec tree_depth t = match t with
  | Empty -> 0
  | Tree (l, _, r) -> 1 + max (tree_depth l) (tree_depth r)

(* TODO: Implement the function. *)
let tree_depth_cps t =
  let rec depth_helper tree sc =
    match tree with
    | Empty -> sc 0
    | Tree(l, _, r) ->
        depth_helper l (fun dl ->
          depth_helper r (fun dr ->
            sc (1 + max dl dr)))
  in
  depth_helper t (fun x -> x)

(* Question 2: Finding Subtrees *)
(* The prefix of a subtree is defined as the list of parent's values from the root down to the parent of that subtree. *)
(* TODO: Implement a CPS style find_subtree_cps function. *)
let find_subtree_cps p tree =
  let rec aux current tree sc fc =
    match tree with
    | Empty ->
        if current = p then sc Empty else fc ()
    | Tree(l, a, r) ->
        if current = p then sc tree
        else
          let new_current = current @ [a] in
          aux new_current l sc (fun () ->
            aux new_current r sc fc)
  in
  aux [] tree (fun t -> Some t) (fun () -> None)

(* Question 3: Arithmetic Expression Parser *)

type token = INT of int | PLUS | TIMES | LPAREN | RPAREN
type expr = Const of int | Plus of expr * expr | Times of expr * expr

(* ('r, 'a) parser_LN = token list -> (unit -> 'r) -> (token list -> 'a -> 'r) -> 'r *)

let rec parse_E tokens sc fc =
  parse_T tokens (fun tokens1 t ->
    parse_E' tokens1 t sc fc) fc

and parse_E' tokens t sc fc =
  match tokens with
  | PLUS :: rest ->
      parse_T rest (fun tokens2 t2 ->
        let new_expr = Plus(t, t2) in
        parse_E' tokens2 new_expr sc fc) fc
  | _ -> sc tokens t

and parse_T tokens sc fc =
  parse_F tokens (fun tokens1 f ->
    parse_T' tokens1 f sc fc) fc

and parse_T' tokens t sc fc =
  match tokens with
  | TIMES :: rest ->
      parse_F rest (fun tokens2 f ->
        let new_expr = Times(t, f) in
        parse_T' tokens2 new_expr sc fc) fc
  | _ -> sc tokens t

and parse_F tokens sc fc =
  match tokens with
  | INT n :: rest -> sc rest (Const n)
  | LPAREN :: rest ->
      parse_E rest (fun tokens1 e ->
        (match tokens1 with
         | RPAREN :: tokens2 -> sc tokens2 e
         | _ -> fc ())) fc
  | _ -> fc ()

(* TODO: Implement a CPS style parser function. *)
let parser_cps tokens =
  parse_E tokens (fun tokens' e ->
    match tokens' with
    | [] -> Some e
    | _ -> None)
  (fun () -> None)

let check_parser t v = match parser_cps t with
  | None -> None
  | Some(e) -> Some(eval e v)