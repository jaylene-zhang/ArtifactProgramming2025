type 'a tree = Empty | Tree of 'a tree * 'a * 'a tree

(* Question 1: Tree Depth *)
let rec tree_depth t = match t with
  | Empty -> 0
  | Tree (l, _, r) -> 1 + max (tree_depth l) (tree_depth r)

(* TODO: Implement a CPS style tree_depth_cps function. *)
let tree_depth_cps t =
  let rec depth_helper t k =
    match t with
    | Empty -> k 0
    | Tree (l, _, r) ->
        depth_helper l (fun dl ->
          depth_helper r (fun dr ->
            k (1 + max dl dr)))
  in
  depth_helper t (fun x -> x)

(* Question 2: Finding Subtrees *)
(* TODO: Implement a CPS style find_subtree_cps function. *)
let find_subtree_cps ls tree =
  let rec search acc tree sc fc =
    match tree with
    | Empty -> if acc = ls then sc Empty else fc ()
    | Tree (l, v, r) ->
        if acc = ls then sc (Tree (l, v, r))
        else search (acc @ [v]) l sc (fun () -> search (acc @ [v]) r sc fc)
  in
  search [] tree (fun t -> Some t) (fun () -> None)

(* Question 3: Arithmetic Expression Parser *)
(* TODO: Implement a CPS style parser function. *)
type token = INT of int | PLUS | TIMES | LPAREN | RPAREN

type expr = Const of int | Plus of expr * expr | Times of expr * expr

let rec factor tokens fc sc =
  match tokens with
  | INT n :: rest -> sc rest (Const n)
  | LPAREN :: rest ->
      expr rest fc (fun tokens' exp ->
        match tokens' with
        | RPAREN :: rest2 -> sc rest2 exp
        | _ -> fc ())
  | _ -> fc ()

and term tokens fc sc =
  factor tokens fc (fun tokens' f ->
    term_tail f tokens' fc sc)

and term_tail left tokens fc sc =
  match tokens with
  | TIMES :: rest ->
      factor rest fc (fun tokens' f ->
        term_tail (Times (left, f)) tokens' fc sc)
  | _ -> sc tokens left

and expr tokens fc sc =
  term tokens fc (fun tokens' t ->
    expr_tail t tokens' fc sc)

and expr_tail left tokens fc sc =
  match tokens with
  | PLUS :: rest ->
      term rest fc (fun tokens' t ->
        expr_tail (Plus (left, t)) tokens' fc sc)
  | _ -> sc tokens left

let parser_cps tokens =
  expr tokens (fun () -> None) (fun tokens' exp ->
    match tokens' with
    | [] -> Some exp
    | _ -> None)

let rec eval e _ =
  match e with
  | Const n -> n
  | Plus (e1, e2) -> eval e1 0 + eval e2 0
  | Times (e1, e2) -> eval e1 0 * eval e2 0

let check_parser t v =
  match parser_cps t with
  | None -> None
  | Some e -> Some (eval e v)