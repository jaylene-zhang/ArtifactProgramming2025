(* Question 1: Tree Depth *)

let rec tree_depth t = match t with
  | Empty -> 0
  | Tree (l, _, r) -> 1 + max (tree_depth l) (tree_depth r)

let tree_depth_cps t = 
  let rec depth_helper tree sc =
    match tree with
    | Empty -> sc 0
    | Tree (l, _, r) -> 
        depth_helper l (fun left_depth ->
          depth_helper r (fun right_depth ->
            sc (1 + max left_depth right_depth)))
  in
  depth_helper t (fun x -> x)

(* Question 2: Finding Subtrees *)

let find_subtree_cps ls tree =
  let rec helper ls tree sc fc =
    match ls, tree with
    | [], _ -> sc tree
    | _, Empty -> fc ()
    | hd::tl, Tree(left, v, right) ->
        if hd = v then
          helper tl left 
            (fun t' -> sc t')
            (fun () -> helper tl right sc fc)
        else
          helper (hd::tl) left
            (fun t' -> sc t')
            (fun () -> helper (hd::tl) right sc fc)
  in
  helper ls tree (fun t -> Some t) (fun () -> None)

(* Question 3: Arithmetic Expression Parser *)

type token = 
  | CONST of int
  | PLUS
  | MINUS
  | TIMES
  | DIV
  | LPAREN
  | RPAREN

type expr = 
  | Const of int
  | Plus of expr * expr
  | Minus of expr * expr
  | Times of expr * expr
  | Div of expr * expr

let eval expr env =
  let rec eval_helper e =
    match e with
    | Const n -> n
    | Plus (e1, e2) -> eval_helper e1 + eval_helper e2
    | Minus (e1, e2) -> eval_helper e1 - eval_helper e2
    | Times (e1, e2) -> eval_helper e1 * eval_helper e2
    | Div (e1, e2) -> eval_helper e1 / eval_helper e2
  in
  eval_helper expr

let parser_cps tokens =
  let rec parse_expr tokens fc sc =
    parse_term tokens fc (fun tokens' term ->
      parse_expr_tail tokens' term fc sc)
  
  and parse_expr_tail tokens left fc sc =
    match tokens with
    | PLUS :: rest ->
        parse_term rest fc (fun tokens' term ->
          parse_expr_tail tokens' (Plus (left, term)) fc sc)
    | MINUS :: rest ->
        parse_term rest fc (fun tokens' term ->
          parse_expr_tail tokens' (Minus (left, term)) fc sc)
    | _ -> sc tokens left
  
  and parse_term tokens fc sc =
    parse_factor tokens fc (fun tokens' factor ->
      parse_term_tail tokens' factor fc sc)
  
  and parse_term_tail tokens left fc sc =
    match tokens with
    | TIMES :: rest ->
        parse_factor rest fc (fun tokens' factor ->
          parse_term_tail tokens' (Times (left, factor)) fc sc)
    | DIV :: rest ->
        parse_factor rest fc (fun tokens' factor ->
          parse_term_tail tokens' (Div (left, factor)) fc sc)
    | _ -> sc tokens left
  
  and parse_factor tokens fc sc =
    match tokens with
    | LPAREN :: rest ->
        parse_expr rest fc (fun tokens' expr ->
          match tokens' with
          | RPAREN :: rest' -> sc rest' expr
          | _ -> fc ())
    | CONST n :: rest -> sc rest (Const n)
    | _ -> fc ()
  in
  
  parse_expr tokens (fun () -> None) (fun tokens' expr ->
    if tokens' = [] then Some expr else None)

let check_parser t v = match parser_cps t with
  | None -> None
  | Some(e) -> Some(eval e v)