```ocaml
(* Question 1: Tree Depth *)
let rec tree_depth t = match t with
  | Empty -> 0
  | Tree (l, _, r) -> 1 + max (tree_depth l) (tree_depth r)

let tree_depth_cps t =
  let rec depth_helper t sc fc =
    match t with
    | Empty -> sc 0
    | Tree (l, _, r) ->
      depth_helper l (fun x ->
        depth_helper r (fun y ->
          sc (1 + max x y)
        ) fc
      ) fc
  in
  depth_helper t (fun x -> Some x) (fun () -> None)


(* Question 2: Finding Subtrees *)
let find_subtree_cps ls tree =
  let rec helper ls tree sc fc =
    match ls with
    | [] -> sc tree
    | h :: tl ->
      match tree with
      | Empty -> fc ()
      | Tree (l, v, r) ->
        if v = h then
          helper tl l (sc) (fun () ->
            helper tl r (sc) fc
          )
        else fc ()
  in
  helper ls tree (fun x -> Some x) (fun () -> None)


(* Question 3: Arithmetic Expression Parser *)
type expr =
  | Const of int
  | Plus of expr * expr
  | Minus of expr * expr
  | Times of expr * expr
  | Div of expr * expr

type token =
  | Num of int
  | PlusT
  | MinusT
  | TimesT
  | DivT
  | LParen
  | RParen

let rec parser_cps t =
  let rec expr_helper t sc fc =
    term_helper t (fun e ->
      match t with
      | PlusT :: tl ->
        expr_helper tl (fun e' ->
          sc (Plus (e, e'))
        ) fc
      | MinusT :: tl ->
        expr_helper tl (fun e' ->
          sc (Minus (e, e'))
        ) fc
      | _ -> sc e
    ) fc
  and term_helper t sc fc =
    factor_helper t (fun e ->
      match t with
      | TimesT :: tl ->
        term_helper tl (fun e' ->
          sc (Times (e, e'))
        ) fc
      | DivT :: tl ->
        term_helper tl (fun e' ->
          sc (Div (e, e'))
        ) fc
      | _ -> sc e
    ) fc
  and factor_helper t sc fc =
    match t with
    | Num n :: tl -> sc (Const n)
    | LParen :: tl ->
      expr_helper tl (fun e ->
        match tl with
        | RParen :: tl' -> sc e
        | _ -> fc ()
      ) fc
    | _ -> fc ()
  in
  expr_helper t (fun e -> Some e) (fun () -> None)

let check_parser t v = match parser_cps t with
  | None -> None
  | Some(e) -> Some(eval e v)
```