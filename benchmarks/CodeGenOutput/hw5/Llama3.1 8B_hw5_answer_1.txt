Here are the solutions to the exercises:

```ocaml
(* Question 1: Tree Depth *)

let rec tree_depth_cps t k =
  let depth_helper t k f =
    match t with
    | Empty -> k 0
    | Tree (lt, v, rt) ->
       depth_helper lt (fun lv ->
         depth_helper rt (fun rv -> f (1 + max lv rv)) k)
  in
  depth_helper t k (fun x -> k x)

(* Question 2: Finding Subtrees *)

type 'a tree = Empty | Tree of 'a tree * 'a * 'a tree

let rec find_subtree_cps ls tree sc fc =
  let rec helper ls tree sc fc =
    match tree, ls with
    | Empty, _ -> fc ()
    | _, [] -> fc ()
    | Tree (_, v, rt), tl :: tl ->
       if List.hd tl = v then
         helper lt rt (fun _ -> helper ls tl sc fc)
            (fun _ -> fc ())
       else sc ()
  in
  helper [] tree sc fc

(* Question 3: Parser *)

type token = Empty | Var of string | Const of int | Plus | Minus | Times

let rec parser_expr_cps t k =
  try_parse_ident_cps t k

and try_parse_plus_cps t k =
  parser_term_cps (try_parse_times_cps t) (fun vl ->
    parser_expr_cps t (fun vr -> k (Plus (vl, vr)))
  ) k

and parser_term_cps t k =
  try_parse_times_cps t k

and try_parse_times_cps t k =
  parser_factor_cps (try_parse_plus_cps t) (fun vl ->
    parser_term_cps t (fun vr -> k (Times (vl, vr)))
  ) k

and parser_factor_cps t k =
  try_parse_ident_cps t
    (fun id -> try_parse_const_cps t (Const id) k)
    k

and try_parse_ident_cps t sc fc k =
  match t with
  | l :: tl ->
     match l with
     | Var id -> sc (Const id)
     | _ -> fc ()
  | _ -> fc ()

and try_parse_const_cps t v k =
  match t with
  | [] -> k v
  | dd :: d :: tl when dd <> d ->
     k v
  | _ :: tl ->
     k v

let parser_cps t =
  parser_expr_cps t (fun e -> Some e) (fun () -> None)

let check_parser t v = match parser_cps t with
  | None -> None
  | Some(e) -> Some(eval e v)
```

Note: In the `check_parser` function, I assume that `eval` is implemented elsewhere, as required.