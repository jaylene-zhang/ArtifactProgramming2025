(* Question 1: Tree Depth *)
let rec tree_depth t = match t with
  | Empty -> 0
  | Tree (l, _, r) -> 1 + max (tree_depth l) (tree_depth r)

let rec depth_helper t k =
  match t with
  | Empty -> k 0
  | Tree (l, _, r) -> depth_helper l (fun x -> k (1 + max x (depth_helper r (fun y -> y))))


let tree_depth_cps t = depth_helper t (fun x -> x)


(* Question 2: Finding Subtrees *)
let find_subtree_cps ls tree =
  let rec helper ls tree sc fc =
    match (tree, ls) with
    | Empty, _ -> fc []
    | Tree (l, r, _), h::t when h = r -> helper l t sc fc
    | Tree (l, r, _), h::t when h = l -> helper t (Tree (l, r, Empty)) sc fc
    | _, [] -> sc tree
    | _, _ -> fc []
  in
  helper tree ls (fun t' -> Some t') (fun () -> None)


(* Question 3: Arithmetic Expression Parser *)
let const_cps ts k =
  match ts with
  | Const(n)::ts' -> k (Const n) ts'
  | _ -> k None ts

let var_cps ts k = k None ts

let add_cps ts k =
  let rec helper ts acc k =
    match ts with
    | Plus(e1, e2)::ts' -> helper ts' (fun e1 e2 -> Some (Plus(e1, e2))) k
    | _::ts' -> helper ts' (fun e -> Some e) k
    | [] -> k (Some (eval acc ts)) []
  in
  helper ts (const_cps ts) k

let rec parser_cps ts k =
  match ts with
  | Const _::ts' -> const_cps ts' k
  | Var _::ts' -> var_cps ts' k
  | _::Plus(e1, e2)::ts' -> add_cps ts' (fun e1 e2 -> parser_cps [e1; e2] k)
  | _ -> k None ts
(* TODO: Implement a CPS style parser function.*)