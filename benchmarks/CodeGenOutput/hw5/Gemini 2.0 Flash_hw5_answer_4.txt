```ocaml
(* Question 1: Tree Depth *)

let rec tree_depth t = match t with
  | Empty -> 0
  | Tree (l, _, r) -> 1 + max (tree_depth l) (tree_depth r)

(* TODO: Implement a CPS style tree_depth_cps function.*)
let tree_depth_cps t =
  let rec depth_helper t k =
    match t with
    | Empty -> k 0
    | Tree (l, _, r) ->
      depth_helper l (fun dl ->
          depth_helper r (fun dr ->
              k (1 + max dl dr)))
  in
  depth_helper t (fun x -> x)

(* Question 2: Finding Subtrees *)

(* TODO: Implement a CPS style find_subtree_cont function.*)
let find_subtree_cps ls tree =
  let rec helper ls tree sc fc =
    match ls, tree with
    | [], _ -> sc (Some tree)
    | _, Empty -> fc ()
    | x::xs, Tree(l,v,r) ->
      if x = v then
        helper xs tree sc fc
      else
        helper ls l (fun res ->
            match res with
            | Some _ -> sc res
            | None -> helper ls r sc fc
          ) fc
  in
  helper ls tree (fun x -> x) (fun () -> None)

(* Question 3: Arithmetic Experssion Parser *)

(* TODO: Implement a CPS style parser function.*)
type ('r, 'a) parser_LN = token list -> (unit -> 'r) -> (token list -> 'a -> 'r) -> 'r

let parser_cps t =
  let eval_op op e1 e2 =
    match op with
    | Plus -> e1 + e2
    | Minus -> e1 - e2
    | Times -> e1 * e2
    | Divide -> if e2 = 0 then failwith "Division by zero" else e1 / e2
  in
  let rec expr tokens succ fail =
    term tokens (fun t_res ->
        rest_expr t_res succ fail
      ) fail
  and rest_expr e1 tokens succ fail =
    match tokens with
    | Op op :: rest ->
      term rest (fun t_res ->
          rest_expr (BinOp(op, e1, t_res)) tokens succ fail
        ) fail
    | _ -> succ e1 tokens
  and term tokens succ fail =
    factor tokens (fun f_res ->
        rest_term f_res tokens succ fail
      ) fail
  and rest_term e1 tokens succ fail =
    match tokens with
    | Op op :: rest when op = Times || op = Divide ->
      factor rest (fun f_res ->
          rest_term (BinOp(op, e1, f_res)) tokens succ fail
        ) fail
    | _ -> succ e1 tokens
  and factor tokens succ fail =
    match tokens with
    | Num n :: rest -> succ (Const n) rest
    | LParen :: rest ->
      expr rest (fun e_res tokens_after ->
          match tokens_after with
          | RParen :: rest_after ->
            succ e_res rest_after
          | _ -> fail
        ) fail
    | _ -> fail

  in
  let succ res tokens = Some res in
  let fail = None in
  match expr t (fun e tokens -> succ e tokens ) fail with
  | Some(expr) -> Some(expr)
  | None -> None

let check_parser t v = match parser_cps t with
  | None -> None
  | Some(e) -> Some(eval e v)
```