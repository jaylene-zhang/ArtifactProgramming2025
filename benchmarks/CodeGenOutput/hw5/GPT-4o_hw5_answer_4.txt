```ocaml
(* Question 1: Tree Depth *)

let tree_depth_cps t =
  let rec depth_helper t sc =
    match t with
    | Empty -> sc 0
    | Tree (l, _, r) ->
        depth_helper l (fun dl ->
        depth_helper r (fun dr ->
        sc (1 + max dl dr)))
  in
  depth_helper t (fun x -> x)

(* Question 2: Finding Subtrees *)

let find_subtree_cps ls tree =
  let rec helper ls tree sc fc =
    match (ls, tree) with
    | ([], t) -> sc t
    | (_, Empty) -> fc ()
    | (x::xs, Tree (l, v, r)) ->
        if x = v then helper xs l sc (fun () -> helper xs r sc fc)
        else fc ()
  in
  helper ls tree (fun t -> Some t) (fun () -> None)

(* Question 3: Arithmetic Expression Parser *)

let parser_cps t =
  let rec parse_expr tokens sc fc =
    parse_term tokens (fun tokens_left term_result ->
      parse_expr_rhs tokens_left term_result sc fc)
      fc
  and parse_expr_rhs tokens term_result sc fc =
    match tokens with
    | Plus :: rest ->
        parse_term rest (fun tokens_left next_term_result ->
          parse_expr_rhs tokens_left (Plus (term_result, next_term_result)) sc fc)
          fc
    | _ -> sc tokens term_result
  and parse_term tokens sc fc =
    parse_factor tokens (fun tokens_left factor_result ->
      parse_term_rhs tokens_left factor_result sc fc)
      fc
  and parse_term_rhs tokens factor_result sc fc =
    match tokens with
    | Mult :: rest ->
        parse_factor rest (fun tokens_left next_factor_result ->
          parse_term_rhs tokens_left (Mult (factor_result, next_factor_result)) sc fc)
          fc
    | _ -> sc tokens factor_result
  and parse_factor tokens sc fc =
    match tokens with
    | Int n :: rest -> sc rest (Const n)
    | LParen :: rest ->
        parse_expr rest (fun tokens_left expr_result ->
          match tokens_left with
          | RParen :: rest_after -> sc rest_after expr_result
          | _ -> fc tokens)
          fc
    | _ -> fc tokens
  in
  parse_expr t (fun _ expr -> Some expr) (fun _ -> None)
```