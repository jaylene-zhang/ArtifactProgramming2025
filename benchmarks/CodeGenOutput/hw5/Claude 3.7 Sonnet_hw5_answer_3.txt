(* Question 1: Tree Depth *)

let rec tree_depth t = match t with
  | Empty -> 0
  | Tree (l, _, r) -> 1 + max (tree_depth l) (tree_depth r)

let tree_depth_cps t = 
  let rec depth_helper t sc =
    match t with
    | Empty -> sc 0
    | Tree (l, _, r) -> depth_helper l (fun ld -> 
        depth_helper r (fun rd ->
          sc (1 + max ld rd)))
  in
  depth_helper t (fun x -> x)

(* Question 2: Finding Subtrees *)

let find_subtree_cps ls tree =
  let rec helper ls tree sc fc =
    match ls, tree with
    | [], _ -> sc tree
    | x::xs, Empty -> fc ()
    | x::xs, Tree (l, v, r) ->
        if x = v then
          helper xs l (fun res -> sc res) 
                    (fun () -> helper xs r (fun res -> sc res) fc)
        else
          fc ()
  in
  helper ls tree (fun t -> Some t) (fun() -> None)

(* Question 3: Arithmetic Experssion Parser *)

type ('r, 'a) parser_LN = token list -> (unit -> 'r) -> (token list -> 'a -> 'r) -> 'r

let parser_cps t =
  let rec expr_parser tokens fc sc =
    term_parser tokens fc (fun tokens' term ->
      match tokens' with
      | PLUS::rest ->
          expr_parser rest fc (fun tokens'' expr ->
            sc tokens'' (Plus(term, expr)))
      | MINUS::rest ->
          expr_parser rest fc (fun tokens'' expr ->
            sc tokens'' (Minus(term, expr)))
      | _ -> sc tokens' term)
  
  and term_parser tokens fc sc =
    factor_parser tokens fc (fun tokens' factor ->
      match tokens' with
      | TIMES::rest ->
          term_parser rest fc (fun tokens'' term ->
            sc tokens'' (Times(factor, term)))
      | DIV::rest ->
          term_parser rest fc (fun tokens'' term ->
            sc tokens'' (Div(factor, term)))
      | _ -> sc tokens' factor)
  
  and factor_parser tokens fc sc =
    match tokens with
    | LPAREN::rest ->
        expr_parser rest fc (fun tokens' expr ->
          match tokens' with
          | RPAREN::rest' -> sc rest' expr
          | _ -> fc ())
    | INT n::rest -> sc rest (Const n)
    | VAR x::rest -> sc rest (Var x)
    | _ -> fc ()
  in
  
  expr_parser t (fun () -> None) (fun remaining expr ->
    if remaining = [] then Some expr else None)

let check_parser t v = match parser_cps t with
  | None -> None
  | Some(e) -> Some(eval e v)