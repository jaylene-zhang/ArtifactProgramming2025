let tree_depth_cps t =
  let rec depth_helper t k =
    match t with
    | Empty -> k 0
    | Tree (l, _, r) ->
        depth_helper l (fun dl ->
          depth_helper r (fun dr ->
            k (1 + max dl dr)))
  in
  depth_helper t (fun x -> x)

let find_subtree_cps ls tree =
  let rec helper ls tree sc fc =
    match ls, tree with
    | [], _ -> sc tree
    | _, Empty -> fc ()
    | x::xs, Tree (left, v, right) ->
        if x = v then
          helper xs left sc (fun () -> helper xs right sc fc)
        else
          fc ()
  in
  helper ls tree (fun t -> Some t) (fun () -> None)

type token =
  | CONST of int
  | PLUS
  | MINUS
  | TIMES
  | DIV
  | LPAREN
  | RPAREN

type expr =
  | Const of int
  | Plus of expr * expr
  | Minus of expr * expr
  | Times of expr * expr
  | Div of expr * expr

let eval expr v =
  let rec eval_helper e =
    match e with
    | Const n -> n
    | Plus (e1, e2) -> (eval_helper e1) + (eval_helper e2)
    | Minus (e1, e2) -> (eval_helper e1) - (eval_helper e2)
    | Times (e1, e2) -> (eval_helper e1) * (eval_helper e2)
    | Div (e1, e2) -> (eval_helper e1) / (eval_helper e2)
  in
  eval_helper expr

let rec parse_expr tokens sc fc =
  parse_term tokens (fun tokens term ->
    let rec parse_expr_rest tokens term sc fc =
      match tokens with
      | PLUS :: rest ->
          parse_term rest (fun tokens' term' ->
            parse_expr_rest tokens' (Plus (term, term')) sc fc)
      | MINUS :: rest ->
          parse_term rest (fun tokens' term' ->
            parse_expr_rest tokens' (Minus (term, term')) sc fc)
      | _ -> sc tokens term
    in
    parse_expr_rest tokens term sc fc) fc

and parse_term tokens sc fc =
  parse_factor tokens (fun tokens factor ->
    let rec parse_term_rest tokens factor sc fc =
      match tokens with
      | TIMES :: rest ->
          parse_factor rest (fun tokens' factor' ->
            parse_term_rest tokens' (Times (factor, factor')) sc fc)
      | DIV :: rest ->
          parse_factor rest (fun tokens' factor' ->
            parse_term_rest tokens' (Div (factor, factor')) sc fc)
      | _ -> sc tokens factor
    in
    parse_term_rest tokens factor sc fc) fc

and parse_factor tokens sc fc =
  match tokens with
  | CONST n :: rest -> sc rest (Const n)
  | LPAREN :: rest ->
      parse_expr rest (fun tokens' expr ->
        match tokens' with
        | RPAREN :: rest' -> sc rest' expr
        | _ -> fc ()) fc
  | _ -> fc ()

let parser_cps tokens =
  parse_expr tokens (fun tokens expr ->
    if tokens = [] then Some expr else None) (fun () -> None)