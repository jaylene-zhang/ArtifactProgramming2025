(* TODO: Q1a *)
let rec take (n : int) (s : 'a stream) : 'a list =
  if n = 0 then [] else s.head :: (take (n - 1) (s.tail ()))

(* TODO: Q1b *)
let rec drop (n : int) (s : 'a stream) : 'a stream =
  if n = 0 then s else (drop (n - 1) (s.tail ()))

(* TODO: Q2a *)
let zeroes : int stream =
  { head = 0
  ; tail = fun () -> zeroes
  }

(* TODO: Q2b *)
let natural_numbers : int stream =
  { head = 0
  ; tail = fun () -> unfold (fun n -> (n + 1, n + 1)) 1
  }

(* TODO: Q2c *)
let even_numbers : int stream =
  { head = 0
  ; tail = fun () -> unfold (fun n -> (n + 2, n + 2)) 0
  }

(* TODO: Q3 *)
let map2 (f : 'a -> 'b -> 'c) (s1 : 'a stream) (s2 : 'b stream) : 'c stream =
  unfold (fun (a, b) -> ((f a.head b.head), (a.tail (), b.tail ()))) (s1, s2)

(* TODO: Q4a *)
let fibonacci : int stream =
  { head = 0
  ; tail = fun () -> unfold (fun (f1, f2) -> (f2, f1 + f2)) (0, 1)
  }

(* TODO: Q4b *)
let lucas : int stream =
  { head = 2
  ; tail = fun () -> unfold (fun (l1, l2) -> (l2, l1 + l2)) (1, 2)
  }