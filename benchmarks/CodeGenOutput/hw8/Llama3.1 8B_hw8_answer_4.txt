(* TODO: Q1a *)
let rec take (n : int) (s : 'a stream) : 'a list =
  if n <= 0 then []
  else s.head :: take (n - 1) (s.tail ())

(* TODO: Q1b *)
let rec drop (n : int) (s : 'a stream) : 'a stream =
  if n <= 0 then s
  else drop (n - 1) (s.tail ())

(* TODO: Q2a *)
let zeroes : int stream =
  unfold (fun _ -> (0, ()))
  (0)

(* TODO: Q2b *)
let natural_numbers : int stream =
  unfold (fun x -> (x, x + 1))
  (0)

(* TODO: Q2c *)
let even_numbers : int stream =
  let is_even x = x mod 2 = 0 in
  map (fun x -> x) (filter is_even natural_numbers)

(* TODO: Q3 *)
let map2 (f : 'a -> 'b -> 'c) (s1 : 'a stream) (s2 : 'b stream) : 'c stream =
  map (fun (x, y) -> f x y) (zip s1 s2)

(* TODO: Q4a *)
let fibonacci : int stream =
  let rec fib n x1 x2 =
    if n <= 0 then (x1, fib (n + 1) x2 (x1 + x2))
    else (x1, fib (n - 1) x2 (x1 + x2)) in
  unfold fib (0, 1)
  (0, 1)

(* TODO: Q4b *)
let lucas : int stream =
  let rec luc n x1 x2 =
    if n <= 0 then (x1, luc (n + 1) x2 (x1 + x2))
    else (x1, luc (n - 1) x2 (x1 + x2)) in
  unfold luc (2, 1)
  (2, 1)